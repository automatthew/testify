var global = (function() {

  var base64Decode = function(string) {
    return window.atob(string);
  };

  return {
    filesystem: {
      root: {
        "application.coffee": {
          "__stat": {
            "dev": 16777218,
            "mode": 33188,
            "nlink": 1,
            "uid": 501,
            "gid": 20,
            "rdev": 0,
            "blksize": 4096,
            "ino": 4747837,
            "size": 3029,
            "blocks": 8,
            "atime": "2013-05-19T22:23:43.000Z",
            "mtime": "2013-04-21T17:01:51.000Z",
            "ctime": "2013-04-21T17:01:51.000Z",
            "type": "file"
          },
          "__ref": "23c52402856e2dd41b24ee89a97a0dfe"
        },
        "node_modules": {
          "__stat": {
            "dev": 16777218,
            "mode": 16877,
            "nlink": 10,
            "uid": 501,
            "gid": 20,
            "rdev": 0,
            "blksize": 4096,
            "ino": 4717675,
            "size": 340,
            "blocks": 0,
            "atime": "2013-05-19T22:23:16.000Z",
            "mtime": "2013-05-19T22:19:51.000Z",
            "ctime": "2013-05-19T22:19:51.000Z",
            "type": "directory"
          },
          "testify": {
            "__stat": {
              "dev": 16777218,
              "mode": 16877,
              "nlink": 10,
              "uid": 501,
              "gid": 20,
              "rdev": 0,
              "blksize": 4096,
              "ino": 4717675,
              "size": 340,
              "blocks": 0,
              "atime": "2013-05-19T22:23:16.000Z",
              "mtime": "2013-05-19T22:19:51.000Z",
              "ctime": "2013-05-19T22:19:51.000Z",
              "type": "directory"
            },
            "node_modules": {
              "__stat": {
                "dev": 16777218,
                "mode": 16877,
                "nlink": 10,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4717675,
                "size": 340,
                "blocks": 0,
                "atime": "2013-05-19T22:23:16.000Z",
                "mtime": "2013-05-19T22:19:51.000Z",
                "ctime": "2013-05-19T22:19:51.000Z",
                "type": "directory"
              },
              "colors": {
                "__stat": {
                  "dev": 16777218,
                  "mode": 16877,
                  "nlink": 10,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4717675,
                  "size": 340,
                  "blocks": 0,
                  "atime": "2013-05-19T22:23:16.000Z",
                  "mtime": "2013-05-19T22:19:51.000Z",
                  "ctime": "2013-05-19T22:19:51.000Z",
                  "type": "directory"
                },
                "colors.js": {
                  "__stat": {
                    "dev": 16777218,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4748192,
                    "size": 7705,
                    "blocks": 16,
                    "atime": "2013-05-19T22:23:43.000Z",
                    "mtime": "2011-12-09T12:35:20.000Z",
                    "ctime": "2013-04-21T17:16:52.000Z",
                    "type": "file"
                  },
                  "__ref": "a089014e00fc816889fd3a26e987bdbd"
                },
                "example.js": {
                  "__stat": {
                    "dev": 16777218,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4748196,
                    "size": 2039,
                    "blocks": 8,
                    "atime": "2013-05-19T22:23:43.000Z",
                    "mtime": "2011-12-09T12:35:20.000Z",
                    "ctime": "2013-04-21T17:16:52.000Z",
                    "type": "file"
                  },
                  "__ref": "865b933cdca5bf49b1f012335b02ff93"
                },
                "package.json": {
                  "__stat": {
                    "dev": 16777218,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4748189,
                    "size": 1793,
                    "blocks": 8,
                    "atime": "2013-05-19T22:23:43.000Z",
                    "mtime": "2013-04-21T17:16:52.000Z",
                    "ctime": "2013-04-21T17:16:52.000Z",
                    "type": "file"
                  },
                  "__ref": "74c8622078cff87f7a2ddc5b866312ff"
                },
                "test.js": {
                  "__stat": {
                    "dev": 16777218,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4748198,
                    "size": 1958,
                    "blocks": 8,
                    "atime": "2013-05-19T22:23:43.000Z",
                    "mtime": "2011-12-09T12:35:20.000Z",
                    "ctime": "2013-04-21T17:16:52.000Z",
                    "type": "file"
                  },
                  "__ref": "c3451fe7035e99947143be3e88c3eaef"
                }
              },
              "minfinite": {
                "__stat": {
                  "dev": 16777218,
                  "mode": 16877,
                  "nlink": 10,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4717675,
                  "size": 340,
                  "blocks": 0,
                  "atime": "2013-05-19T22:23:16.000Z",
                  "mtime": "2013-05-19T22:19:51.000Z",
                  "ctime": "2013-05-19T22:19:51.000Z",
                  "type": "directory"
                },
                "minfinite.js": {
                  "__stat": {
                    "dev": 16777218,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4748208,
                    "size": 2161,
                    "blocks": 8,
                    "atime": "2013-05-19T22:23:43.000Z",
                    "mtime": "2013-03-04T18:11:25.000Z",
                    "ctime": "2013-04-21T17:16:52.000Z",
                    "type": "file"
                  },
                  "__ref": "d7c4041289e5445eec291db26b21409d"
                },
                "package.json": {
                  "__stat": {
                    "dev": 16777218,
                    "mode": 33188,
                    "nlink": 1,
                    "uid": 501,
                    "gid": 20,
                    "rdev": 0,
                    "blksize": 4096,
                    "ino": 4748204,
                    "size": 581,
                    "blocks": 8,
                    "atime": "2013-05-19T22:23:43.000Z",
                    "mtime": "2013-04-21T17:16:52.000Z",
                    "ctime": "2013-04-21T17:16:52.000Z",
                    "type": "file"
                  },
                  "__ref": "e241c1de18faf4151605d7b35b8b9eab"
                }
              }
            },
            "package.json": {
              "__stat": {
                "dev": 16777218,
                "mode": 33188,
                "nlink": 1,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4748158,
                "size": 2726,
                "blocks": 8,
                "atime": "2013-05-19T22:23:43.000Z",
                "mtime": "2013-04-21T17:16:51.000Z",
                "ctime": "2013-04-21T17:16:51.000Z",
                "type": "file"
              },
              "__ref": "78ddc1b1bc4a5a73b371ac17c278d46b"
            },
            "src": {
              "__stat": {
                "dev": 16777218,
                "mode": 16877,
                "nlink": 10,
                "uid": 501,
                "gid": 20,
                "rdev": 0,
                "blksize": 4096,
                "ino": 4717675,
                "size": 340,
                "blocks": 0,
                "atime": "2013-05-19T22:23:16.000Z",
                "mtime": "2013-05-19T22:19:51.000Z",
                "ctime": "2013-05-19T22:19:51.000Z",
                "type": "directory"
              },
              "context.coffee": {
                "__stat": {
                  "dev": 16777218,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4748165,
                  "size": 4331,
                  "blocks": 16,
                  "atime": "2013-05-19T22:23:43.000Z",
                  "mtime": "2013-04-20T16:46:14.000Z",
                  "ctime": "2013-04-21T17:16:51.000Z",
                  "type": "file"
                },
                "__ref": "1f082de170804a1f8caa134abdafdb55"
              },
              "reporters.coffee": {
                "__stat": {
                  "dev": 16777218,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4748166,
                  "size": 6394,
                  "blocks": 16,
                  "atime": "2013-05-19T22:23:43.000Z",
                  "mtime": "2013-04-21T17:09:23.000Z",
                  "ctime": "2013-04-21T17:16:51.000Z",
                  "type": "file"
                },
                "__ref": "7abe6dc3c91fe653e9c4a2d096ee8684"
              },
              "test.coffee": {
                "__stat": {
                  "dev": 16777218,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4748167,
                  "size": 1584,
                  "blocks": 8,
                  "atime": "2013-05-19T22:23:43.000Z",
                  "mtime": "2013-04-20T17:00:49.000Z",
                  "ctime": "2013-04-21T17:16:51.000Z",
                  "type": "file"
                },
                "__ref": "62e49fef2333868ff4848cf4ec8f121d"
              },
              "testify.coffee": {
                "__stat": {
                  "dev": 16777218,
                  "mode": 33188,
                  "nlink": 1,
                  "uid": 501,
                  "gid": 20,
                  "rdev": 0,
                  "blksize": 4096,
                  "ino": 4748168,
                  "size": 1906,
                  "blocks": 8,
                  "atime": "2013-05-19T22:23:43.000Z",
                  "mtime": "2013-04-21T16:54:10.000Z",
                  "ctime": "2013-04-21T17:16:51.000Z",
                  "type": "file"
                },
                "__ref": "1acd0107c78da6657c2d635a044b63b7"
              }
            }
          }
        },
        "package.json": {
          "__stat": {
            "dev": 16777218,
            "mode": 33188,
            "nlink": 1,
            "uid": 501,
            "gid": 20,
            "rdev": 0,
            "blksize": 4096,
            "ino": 4718701,
            "size": 245,
            "blocks": 8,
            "atime": "2013-05-19T22:23:44.000Z",
            "mtime": "2013-04-19T18:38:38.000Z",
            "ctime": "2013-04-19T18:38:38.000Z",
            "type": "file"
          },
          "__ref": "4da661eb5390996e709a485de49a2fe3"
        }
      },
      content: {
        "23c52402856e2dd41b24ee89a97a0dfe": "MjNjNTI0MDI4NTZlMmRkNDFiMjRlZTg5YTk3YTBkZmU=",
        "a089014e00fc816889fd3a26e987bdbd": "YTA4OTAxNGUwMGZjODE2ODg5ZmQzYTI2ZTk4N2JkYmQ=",
        "865b933cdca5bf49b1f012335b02ff93": "ODY1YjkzM2NkY2E1YmY0OWIxZjAxMjMzNWIwMmZmOTM=",
        "74c8622078cff87f7a2ddc5b866312ff": "ewogICJuYW1lIjogImNvbG9ycyIsCiAgImRlc2NyaXB0aW9uIjogImdldCBjb2xvcnMgaW4geW91ciBub2RlLmpzIGNvbnNvbGUgbGlrZSB3aGF0IiwKICAidmVyc2lvbiI6ICIwLjYuMC0xIiwKICAiYXV0aG9yIjogewogICAgIm5hbWUiOiAiTWFyYWsgU3F1aXJlcyIKICB9LAogICJyZXBvc2l0b3J5IjogewogICAgInR5cGUiOiAiZ2l0IiwKICAgICJ1cmwiOiAiaHR0cDovL2dpdGh1Yi5jb20vTWFyYWsvY29sb3JzLmpzLmdpdCIKICB9LAogICJlbmdpbmVzIjogewogICAgIm5vZGUiOiAiPj0wLjEuOTAiCiAgfSwKICAibWFpbiI6ICJjb2xvcnMiLAogICJyZWFkbWUiOiAiIyBjb2xvcnMuanMgLSBnZXQgY29sb3IgYW5kIHN0eWxlIGluIHlvdXIgbm9kZS5qcyBjb25zb2xlICggYW5kIGJyb3dzZXIgKSBsaWtlIHdoYXRcblxuPGltZyBzcmM9XCJodHRwOi8vaS5pbWd1ci5jb20vZ29KZE8ucG5nXCIgYm9yZGVyID0gXCIwXCIvPlxuXG5cbiMjIEluc3RhbGxhdGlvblxuXG4gICAgbnBtIGluc3RhbGwgY29sb3JzXG5cbiMjIGNvbG9ycyBhbmQgc3R5bGVzIVxuXG4tIGJvbGRcbi0gaXRhbGljXG4tIHVuZGVybGluZVxuLSBpbnZlcnNlXG4tIHllbGxvd1xuLSBjeWFuXG4tIHdoaXRlXG4tIG1hZ2VudGFcbi0gZ3JlZW5cbi0gcmVkXG4tIGdyZXlcbi0gYmx1ZVxuLSByYWluYm93XG4tIHplYnJhXG4tIHJhbmRvbVxuXG4jIyBVc2FnZVxuXG5gYGAganNcbnZhciBjb2xvcnMgPSByZXF1aXJlKCcuL2NvbG9ycycpO1xuXG5jb25zb2xlLmxvZygnaGVsbG8nLmdyZWVuKTsgLy8gb3V0cHV0cyBncmVlbiB0ZXh0XG5jb25zb2xlLmxvZygnaSBsaWtlIGNha2UgYW5kIHBpZXMnLnVuZGVybGluZS5yZWQpIC8vIG91dHB1dHMgcmVkIHVuZGVybGluZWQgdGV4dFxuY29uc29sZS5sb2coJ2ludmVyc2UgdGhlIGNvbG9yJy5pbnZlcnNlKTsgLy8gaW52ZXJzZXMgdGhlIGNvbG9yXG5jb25zb2xlLmxvZygnT01HIFJhaW5ib3dzIScucmFpbmJvdyk7IC8vIHJhaW5ib3cgKGlnbm9yZXMgc3BhY2VzKVxuYGBgXG5cbiMgQ3JlYXRpbmcgQ3VzdG9tIHRoZW1lc1xuXG5gYGBqc1xuXG52YXIgcmVxdWlyZSgnY29sb3JzJyk7XG5cbmNvbG9ycy5zZXRUaGVtZSh7XG4gIHNpbGx5OiAncmFpbmJvdycsXG4gIGlucHV0OiAnZ3JleScsXG4gIHZlcmJvc2U6ICdjeWFuJyxcbiAgcHJvbXB0OiAnZ3JleScsXG4gIGluZm86ICdncmVlbicsXG4gIGRhdGE6ICdncmV5JyxcbiAgaGVscDogJ2N5YW4nLFxuICB3YXJuOiAneWVsbG93JyxcbiAgZGVidWc6ICdibHVlJyxcbiAgZXJyb3I6ICdyZWQnXG59KTtcblxuLy8gb3V0cHV0cyByZWQgdGV4dFxuY29uc29sZS5sb2coXCJ0aGlzIGlzIGFuIGVycm9yXCIuZXJyb3IpO1xuXG4vLyBvdXRwdXRzIHllbGxvdyB0ZXh0XG5jb25zb2xlLmxvZyhcInRoaXMgaXMgYSB3YXJuaW5nXCIud2Fybik7XG5gYGBcblxuXG4jIyMgQ29udHJpYnV0b3JzIFxuXG5NYXJhayAoTWFyYWsgU3F1aXJlcylcbkFsZXhpcyBTZWxsaWVyIChjbG91ZGhlYWQpXG5tbWFsZWNraSAoTWFjaWVqIE1hxYJlY2tpKVxubmljb3JlZWQgKE5pY28gUmVlZClcbm1vcmdhbnJhbGxlbiAoTW9yZ2FuIEFsbGVuKVxuSnVzdGluQ2FtcGJlbGwgKEp1c3RpbiBDYW1wYmVsbClcbmRlZCAoRHVzdGluIERpYXopXG5cblxuIyMjIyAgLCBNYXJhayBTcXVpcmVzICwgSnVzdGluIENhbXBiZWxsLCBEdXN0aW4gRGlheiAoQGRlZClcbiIsCiAgInJlYWRtZUZpbGVuYW1lIjogIlJlYWRNZS5tZCIsCiAgIl9pZCI6ICJjb2xvcnNAMC42LjAtMSIsCiAgIl9mcm9tIjogImNvbG9yc0AwLjYueCIKfQo=",
        "c3451fe7035e99947143be3e88c3eaef": "YzM0NTFmZTcwMzVlOTk5NDcxNDNiZTNlODhjM2VhZWY=",
        "d7c4041289e5445eec291db26b21409d": "ZDdjNDA0MTI4OWU1NDQ1ZWVjMjkxZGIyNmIyMTQwOWQ=",
        "e241c1de18faf4151605d7b35b8b9eab": "ewogICJuYW1lIjogIm1pbmZpbml0ZSIsCiAgInZlcnNpb24iOiAiMC4xLjAiLAogICJkZXNjcmlwdGlvbiI6ICJNaW5pbWFsIEZTTSBjbGFzcyIsCiAgImF1dGhvciI6IHsKICAgICJuYW1lIjogIk1hdHRoZXcgS2luZyIsCiAgICAiZW1haWwiOiAiYXV0b21hdHRoZXdAZ21haWwuY29tIgogIH0sCiAgIm1haW4iOiAibWluZmluaXRlLmpzIiwKICAiZmlsZXMiOiBbCiAgICAibWluZmluaXRlLmpzIgogIF0sCiAgInNjcmlwdHMiOiB7fSwKICAicmVwb3NpdG9yeSI6IHsKICAgICJ0eXBlIjogImdpdCIsCiAgICAidXJsIjogImdpdEBnaXRodWIuY29tOmF1dG9tYXR0aGV3L21pbmZpbml0ZS5naXQiCiAgfSwKICAiaG9tZXBhZ2UiOiAiaHR0cHM6Ly9naXRodWIuY29tL2F1dG9tYXR0aGV3L21pbmZpbml0ZSIsCiAgImtleXdvcmRzIjogWwogICAgImZzbSIsCiAgICAic3RhdGUgbWFjaGluZSIKICBdLAogICJsaWNlbnNlIjogIk1JVCIsCiAgIl9pZCI6ICJtaW5maW5pdGVAMC4xLjAiLAogICJyZWFkbWUiOiAiRVJST1I6IE5vIFJFQURNRS5tZCBmaWxlIGZvdW5kISIsCiAgIl9mcm9tIjogIm1pbmZpbml0ZUAwLjEueCIKfQo=",
        "78ddc1b1bc4a5a73b371ac17c278d46b": "ewogICJuYW1lIjogInRlc3RpZnkiLAogICJ2ZXJzaW9uIjogIjAuMi4yIiwKICAiZGVzY3JpcHRpb24iOiAic2ltcGxlIGFzeW5jaHJvbm91cyB0ZXN0aW5nIHVzaW5nIGFzc2VydGlvbnMgb2YgeW91ciBjaG9pY2UiLAogICJtYWluIjogInNyYy90ZXN0aWZ5LmNvZmZlZSIsCiAgImJpbiI6IHsKICAgICJ0ZXN0aWZ5IjogImJpbi90ZXN0aWZ5IgogIH0sCiAgImZpbGVzIjogWwogICAgInNyYyIsCiAgICAiYmluLyIsCiAgICAiUkVBRE1FLm1kIiwKICAgICJzdGF0aXN0aWNzLmpzIgogIF0sCiAgImRlcGVuZGVuY2llcyI6IHsKICAgICJvcHRpbWlzdCI6ICIwLjMuNSIsCiAgICAibWljcm90aW1lIjogIjAuMy4zIiwKICAgICJjb2xvcnMiOiAiMC42LngiLAogICAgIm1pbmZpbml0ZSI6ICIwLjEueCIKICB9LAogICJyZXBvc2l0b3J5IjogewogICAgInR5cGUiOiAiZ2l0IiwKICAgICJ1cmwiOiAiZ2l0QGdpdGh1Yi5jb206YXV0b21hdHRoZXcvdGVzdGlmeS5naXQiCiAgfSwKICAiYXV0aG9yIjogewogICAgIm5hbWUiOiAiTWF0dGhldyBLaW5nIiwKICAgICJlbWFpbCI6ICJhdXRvbWF0dGhld0BnbWFpbC5jb20iCiAgfSwKICAibGljZW5zZSI6ICJNSVQiLAogICJyZWFkbWUiOiAiIyBUZXN0aWZ5XG5cblNpbXBsZSBhc3luY2hyb25vdXMgdGVzdGluZywgdXNpbmcgdGhlIGFzc2VydGlvbnMgb2YgeW91ciBjaG9pY2UuXG5cbldyaXR0ZW4gKGFuZCBtb3N0IGVhc2lseSB1c2VkKSBpbiBDb2ZmZWVTY3JpcHQuXG5cblxuIyMgQmFzaWMgdXNhZ2VcblxuYGBgY29mZmVlXG5cblRlc3RpZnkudGVzdCBcImEgc3VpdGUgb2YgdGVzdHNcIiwgKGNvbnRleHQpIC0+XG5cbiAgIyBXaGVuIHlvdSBuZWVkIHRvIHRlc3QgdGhlIHJlc3VsdHMgb2YgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLFxuICAjIGdpdmUgY29udGV4dC50ZXN0KCkgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGFyZ3VtZW50LiAgWW91IGNhblxuICAjIHRoZW4gdXNlIHRoYXQgYXJndW1lbnQgYXMgYSBuZXcgY29udGV4dCBmb3IgbmVzdGluZyB0ZXN0cy5cbiAgY29udGV4dC50ZXN0IFwidGVzdGluZyBzb21ldGhpbmcgYXN5bmNocm9ub3VzXCIsIChjb250ZXh0KSAtPlxuXG4gICAgc29tZV9hc3luY19jYWxsIChlcnJvciwgcmVzdWx0MSkgLT5cblxuICAgICAgIyBJZiB5b3UgZ2l2ZSBjb250ZXh0LnRlc3QoKSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRzLFxuICAgICAgIyB0aGUgdGVzdCBpcyByZXF1aXJlZCB0byBiZSBzeW5jaHJvbm91cywgYW5kIGNvbnNpZGVyZWQgdG8gaGF2ZVxuICAgICAgIyBwYXNzZWQgaWYgdGhlIGZ1bmN0aW9uIHJ1bnMgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgIGNvbnRleHQudGVzdCBcInJlc3VsdCBtYWtlcyBtZSBoYXBweVwiLCAtPlxuICAgICAgICBhc3NlcnQuaWZFcnJvcihlcnJvcilcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdDEsIFwicGllXCIpXG5cbiAgICAgIGNvbnRleHQudGVzdCBcImEgbmVzdGVkIGFzeW5jaHJvbm91cyB0ZXN0XCIsIChjb250ZXh0KSAtPlxuXG4gICAgICAgIGFub3RoZXJfYXN5bmNfY2FsbCByZXN1bHQxLCAgKGVycm9yLCByZXN1bHQyKSAtPlxuXG4gICAgICAgICAgY29udGV4dC50ZXN0IFwicmVzdWx0IG1ha2VzIG1lIGRlZXBseSBoYXBweVwiLCAtPlxuICAgICAgICAgICAgYXNzZXJ0LmlmRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsIHJlc3VsdDIsIFtcImJhY29uXCIsIFwiY2hlZXNlXCIsIFwicGllXCJdXG5cbiAgICAgIGNvbnRleHQudGVzdCBcInNob3J0Y3V0IGZvciBwYXNzaW5nIGFuIGFzeW5jIHRlc3RcIiwgKGNvbnRleHQpIC0+XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sgLT5cbiAgICAgICAgICAjIHlvdSBjYW4gY2FsbCBjb250ZXh0LnBhc3MoKSBpbnN0ZWFkIG9mIHVzaW5nIGEgc3luY2hyb25vdXMgdGVzdFxuICAgICAgICAgIGNvbnRleHQucGFzcygpXG5cbiAgICAgIGNvbnRleHQudGVzdCBcInNob3J0Y3V0IGZvciBmYWlsaW5nIGFuIGFzeW5jIHRlc3RcIiwgKGNvbnRleHQpIC0+XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sgLT5cbiAgICAgICAgICBjb250ZXh0LmZhaWwoKVxuXG5gYGBcblxuUnVuIHlvdXIgdGVzdCBmaWxlcyB3aXRoIHRoZSBgY29mZmVlYCBleGVjdXRhYmxlLCBvciBieSByZXF1aXJpbmcgdGhlbS5cblxuICAgIGNvZmZlZSBwYXRoL3RvL3Rlc3QuY29mZmVlXG5cbiMjIEV4YW1wbGVzXG5cbltUZXN0aW5nIHRoZSBTaHJlZCBIVFRQIGNsaWVudF0oaHR0cHM6Ly9naXRodWIuY29tL2F1dG9tYXR0aGV3L3NocmVkL2Jsb2IvbWFzdGVyL3Rlc3Qvc2hyZWRfdGVzdC5jb2ZmZWUpXG5cbllvdSBjYW4gYWxzbyB1c2UgdGVzdCBuZXN0aW5nIHdpdGggZW50aXJlbHkgc3luY2hyb25vdXMgd29yaywgYXMgYSB3YXkgdG8gc3RydWN0dXJlIHRoZVxudGVzdCByZXN1bHRzOlxuXG5bU2hyZWQncyBoZWFkZXIgcHJvY2Vzc2luZyB0ZXN0XShodHRwczovL2dpdGh1Yi5jb20vYXV0b21hdHRoZXcvc2hyZWQvYmxvYi9tYXN0ZXIvdGVzdC9oZWFkZXJzX3Rlc3QuY29mZmVlKVxuXG5cblxuIiwKICAicmVhZG1lRmlsZW5hbWUiOiAiUkVBRE1FLm1kIiwKICAiX2lkIjogInRlc3RpZnlAMC4yLjIiLAogICJkaXN0IjogewogICAgInNoYXN1bSI6ICJkMTA0NzI1ZmJhNjY0NDUyOWU3MzRiNTY5YTA5ODVjYWNlMmU5ODFhIgogIH0sCiAgIl9mcm9tIjogIi4uLy4uLyIKfQo=",
        "1f082de170804a1f8caa134abdafdb55": "MWYwODJkZTE3MDgwNGExZjhjYWExMzRhYmRhZmRiNTU=",
        "7abe6dc3c91fe653e9c4a2d096ee8684": "N2FiZTZkYzNjOTFmZTY1M2U5YzRhMmQwOTZlZTg2ODQ=",
        "62e49fef2333868ff4848cf4ec8f121d": "NjJlNDlmZWYyMzMzODY4ZmY0ODQ4Y2Y0ZWM4ZjEyMWQ=",
        "1acd0107c78da6657c2d635a044b63b7": "MWFjZDAxMDdjNzhkYTY2NTdjMmQ2MzVhMDQ0YjYzYjc=",
        "4da661eb5390996e709a485de49a2fe3": "ewogICJuYW1lIjogInRlc3RpZnktYnJvd3NlciIsCiAgInZlcnNpb24iOiAiMC4xLjAiLAogICJkZXNjcmlwdGlvbiI6ICJUZXN0aWZ5IGluIHRoZSBicm93c2VyIiwKICAibWFpbiI6ICJhcHBsaWNhdGlvbi5jb2ZmZWUiLAogICJyZXBvc2l0b3J5IjogIiIsCiAgImF1dGhvciI6ICJNYXR0aGV3IEtpbmciLAogICJsaWNlbnNlIjogIk1JVCIsCiAgImRlcGVuZGVuY2llcyI6IHsKICAgICJ0ZXN0aWZ5IjogIjAuMi54IgogIH0KfQo=",
        "c4f9141dbd0d7a4e3dd3d1dc0a64c667": "YzRmOTE0MWRiZDBkN2E0ZTNkZDNkMWRjMGE2NGM2Njc=",
        "b499eb63a89b9e6fb99ef1209a65ace6": "YjQ5OWViNjNhODliOWU2ZmI5OWVmMTIwOWE2NWFjZTY=",
        "4b089ad1310f754af3510dd2da9a1ff7": "NGIwODlhZDEzMTBmNzU0YWYzNTEwZGQyZGE5YTFmZjc=",
        "223f09f17e4aff9f2d05493c688f7934": "MjIzZjA5ZjE3ZTRhZmY5ZjJkMDU0OTNjNjg4Zjc5MzQ=",
        "7b51c3f0555ccb0c0f1fcd91d389ea1a": "N2I1MWMzZjA1NTVjY2IwYzBmMWZjZDkxZDM4OWVhMWE=",
        "d0c9d6cc2490c964b789d43ae4803b7b": "ZDBjOWQ2Y2MyNDkwYzk2NGI3ODlkNDNhZTQ4MDNiN2I=",
        "ddeff58ff67e5d2d686891fc66ebb2b7": "ZGRlZmY1OGZmNjdlNWQyZDY4Njg5MWZjNjZlYmIyYjc="
      },
      native_modules: {
        "assert": "c4f9141dbd0d7a4e3dd3d1dc0a64c667",
        "events": "b499eb63a89b9e6fb99ef1209a65ace6",
        "fs": "4b089ad1310f754af3510dd2da9a1ff7",
        "module": "223f09f17e4aff9f2d05493c688f7934",
        "path": "7b51c3f0555ccb0c0f1fcd91d389ea1a",
        "url": "d0c9d6cc2490c964b789d43ae4803b7b",
        "util": "ddeff58ff67e5d2d686891fc66ebb2b7"
      },
      module_functions: {
        "23c52402856e2dd41b24ee89a97a0dfe": // from: application.coffee
        function(exports, require, module, __filename, __dirname) {
          var Testify, assert, saneTimeout;

          Testify = require("testify");

          assert = require("assert");

          saneTimeout = function(ms, fn) {
            return setTimeout(fn, ms);
          };

          window.onload = function() {
            Testify.reporter = new Testify.DOMReporter("testify", 1000);
            Testify.test("These should all pass", function(context0) {
              context0.test("passing sync 1", function() {
                return assert.ok(true);
              });
              context0.test("passing async", function(context1) {
                return saneTimeout(0, function() {
                  return context1.pass();
                });
              });
              context0.test("passing async.mixed", function(context1) {
                return saneTimeout(400, function() {
                  context1.test("passing async.mixed sync", function() {
                    return assert.ok(true);
                  });
                  return context1.test("passing async.mixed async", function(context2) {
                    return saneTimeout(400, function() {
                      return context2.pass();
                    });
                  });
                });
              });
              context0.test("passing async.sync", function(context1) {
                return saneTimeout(400, function() {
                  context1.test("passing async.sync 1", function() {
                    return assert.ok(true);
                  });
                  return context1.test("passing async sync 2", function() {
                    return assert.ok(true);
                  });
                });
              });
              return context0.test("passing async.async", function(context1) {
                return saneTimeout(400, function() {
                  return context1.test("passing async.async async", function(context2) {
                    return saneTimeout(400, function() {
                      return context2.pass();
                    });
                  });
                });
              });
            });
            return Testify.test("IntentionalFail", function(context) {
              context.test("IntentionalFail sync fail", function() {
                return assert.ok(false);
              });
              context.test("IntentionalFail async", function(context) {
                return saneTimeout(0, function() {
                  return context.fail("Intentional failure");
                });
              });
              context.test("IntentionalFail async.mixed", function(context) {
                return saneTimeout(300, function() {
                  context.test("IntentionalFail async.mixed sync", function() {
                    return assert.ok(false);
                  });
                  context.test("IntentionalFail async.mixed async", function(context) {
                    return saneTimeout(300, function() {
                      return context.fail("Intentional failure");
                    });
                  });
                  return context.test("IntentionalFail async.mixed error", function() {
                    throw new Error("hello!");
                  });
                });
              });
              context.test("IntentionalFail async.sync", function(context) {
                return saneTimeout(300, function() {
                  context.test("IntentionalFail async.sync 1", function() {
                    return assert.ok(false);
                  });
                  return context.test("IntentionalFail async sync 2", function() {
                    return assert.ok(false);
                  });
                });
              });
              context.test("IntentionalFail async.async", function(context) {
                return saneTimeout(300, function() {
                  return context.test("IntentionalFail async.async async", function(context) {
                    return saneTimeout(300, function() {
                      return context.fail("Intentional Failure");
                    });
                  });
                });
              });
              context.test("IntentionalFail async.async", function(context) {
                return saneTimeout(300, function() {
                  return context.test("IntentionalFail async.async incomplete", function(context) {
                    return saneTimeout(300, function() {
                      return console.log("\nWork done, but no completion for this context");
                    });
                  });
                });
              });
              return context.test("Timing out intentionally", function(context) {
                context.test("forced timeout", function(context) {
                  context.timeout(3 * 100);
                  return saneTimeout(6 * 100, function() {
                    return context.pass();
                  });
                });
                return context.test("cancelled timeout", function(context) {
                  return saneTimeout(2 * 100, function() {
                    return context.fail("Intentional Failure");
                  });
                });
              });
            });
          };

        },

        "a089014e00fc816889fd3a26e987bdbd": // from: node_modules/testify/node_modules/colors/colors.js
        function(exports, require, module, __filename, __dirname) {
          /*
colors.js

Copyright (c) 2010

Marak Squires
Alexis Sellier (cloudhead)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

          var isHeadless = false;

          if (typeof module !== 'undefined') {
            isHeadless = true;
          }

          if (!isHeadless) {
            var exports = {};
            var module = {};
            var colors = exports;
            exports.mode = "browser";
          } else {
            exports.mode = "console";
          }

          //
          // Prototypes the string object to have additional method calls that add terminal colors
          //
          var addProperty = function(color, func) {
            var allowOverride = ['bold'];
            exports[color] = function(str) {
              return func.apply(str);
            };
            String.prototype.__defineGetter__(color, func);
          }

          //
          // Iterate through all default styles and colors
          //

          var x = ['bold', 'underline', 'italic', 'inverse', 'grey', 'black', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
          x.forEach(function(style) {

            // __defineGetter__ at the least works in more browsers
            // http://robertnyman.com/javascript/javascript-getters-setters.html
            // Object.defineProperty only works in Chrome
            addProperty(style, function() {
              return stylize(this, style);
            });
          });

          function sequencer(map) {
            return function() {
              if (!isHeadless) {
                return this.replace(/( )/, '$1');
              }
              var exploded = this.split("");
              var i = 0;
              exploded = exploded.map(map);
              return exploded.join("");
            }
          }

          var rainbowMap = (function() {
            var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
            return function(letter, i, exploded) {
              if (letter == " ") {
                return letter;
              } else {
                return stylize(letter, rainbowColors[i++ % rainbowColors.length]);
              }
            }
          })();

          exports.addSequencer = function(name, map) {
            addProperty(name, sequencer(map));
          }

          exports.addSequencer('rainbow', rainbowMap);
          exports.addSequencer('zebra', function(letter, i, exploded) {
            return i % 2 === 0 ? letter : letter.inverse;
          });

          exports.setTheme = function(theme) {
            Object.keys(theme).forEach(function(prop) {
              addProperty(prop, function() {
                return exports[theme[prop]](this);
              });
            });
          }

          function stylize(str, style) {

            if (exports.mode == 'console') {
              var styles = {
                //styles
                'bold': ['\033[1m', '\033[22m'],
                'italic': ['\033[3m', '\033[23m'],
                'underline': ['\033[4m', '\033[24m'],
                'inverse': ['\033[7m', '\033[27m'],
                //grayscale
                'white': ['\033[37m', '\033[39m'],
                'grey': ['\033[90m', '\033[39m'],
                'black': ['\033[30m', '\033[39m'],
                //colors
                'blue': ['\033[34m', '\033[39m'],
                'cyan': ['\033[36m', '\033[39m'],
                'green': ['\033[32m', '\033[39m'],
                'magenta': ['\033[35m', '\033[39m'],
                'red': ['\033[31m', '\033[39m'],
                'yellow': ['\033[33m', '\033[39m']
              };
            } else if (exports.mode == 'browser') {
              var styles = {
                //styles
                'bold': ['<b>', '</b>'],
                'italic': ['<i>', '</i>'],
                'underline': ['<u>', '</u>'],
                'inverse': ['<span style="background-color:black;color:white;">', '</span>'],
                //grayscale
                'white': ['<span style="color:white;">', '</span>'],
                'grey': ['<span style="color:grey;">', '</span>'],
                'black': ['<span style="color:black;">', '</span>'],
                //colors
                'blue': ['<span style="color:blue;">', '</span>'],
                'cyan': ['<span style="color:cyan;">', '</span>'],
                'green': ['<span style="color:green;">', '</span>'],
                'magenta': ['<span style="color:magenta;">', '</span>'],
                'red': ['<span style="color:red;">', '</span>'],
                'yellow': ['<span style="color:yellow;">', '</span>']
              };
            } else if (exports.mode == 'none') {
              return str;
            } else {
              console.log('unsupported mode, try "browser", "console" or "none"');
            }
            return styles[style][0] + str + styles[style][1];
          };

          // don't summon zalgo
          addProperty('zalgo', function() {
            return zalgo(this);
          });

          // please no
          function zalgo(text, options) {
            var soul = {
              "up": ['̍', '̎', '̄', '̅', '̿', '̑', '̆', '̐', '͒', '͗', '͑', '̇', '̈', '̊', '͂', '̓', '̈', '͊', '͋', '͌', '̃', '̂', '̌', '͐', '̀', '́', '̋', '̏', '̒', '̓', '̔', '̽', '̉', 'ͣ', 'ͤ', 'ͥ', 'ͦ', 'ͧ', 'ͨ', 'ͩ', 'ͪ', 'ͫ', 'ͬ', 'ͭ', 'ͮ', 'ͯ', '̾', '͛', '͆', '̚'],
              "down": ['̖', '̗', '̘', '̙', '̜', '̝', '̞', '̟', '̠', '̤', '̥', '̦', '̩', '̪', '̫', '̬', '̭', '̮', '̯', '̰', '̱', '̲', '̳', '̹', '̺', '̻', '̼', 'ͅ', '͇', '͈', '͉', '͍', '͎', '͓', '͔', '͕', '͖', '͙', '͚', '̣'],
              "mid": ['̕', '̛', '̀', '́', '͘', '̡', '̢', '̧', '̨', '̴', '̵', '̶', '͜', '͝', '͞', '͟', '͠', '͢', '̸', '̷', '͡', ' ҉']
            },
            all = [].concat(soul.up, soul.down, soul.mid),
              zalgo = {};

            function randomNumber(range) {
              r = Math.floor(Math.random() * range);
              return r;
            };

            function is_char(character) {
              var bool = false;
              all.filter(function(i) {
                bool = (i == character);
              });
              return bool;
            }

            function heComes(text, options) {
              result = '';
              options = options || {};
              options["up"] = options["up"] || true;
              options["mid"] = options["mid"] || true;
              options["down"] = options["down"] || true;
              options["size"] = options["size"] || "maxi";
              var counts;
              text = text.split('');
              for (var l in text) {
                if (is_char(l)) {
                  continue;
                }
                result = result + text[l];

                counts = {
                  "up": 0,
                  "down": 0,
                  "mid": 0
                };

                switch (options.size) {
                case 'mini':
                  counts.up = randomNumber(8);
                  counts.min = randomNumber(2);
                  counts.down = randomNumber(8);
                  break;
                case 'maxi':
                  counts.up = randomNumber(16) + 3;
                  counts.min = randomNumber(4) + 1;
                  counts.down = randomNumber(64) + 3;
                  break;
                default:
                  counts.up = randomNumber(8) + 1;
                  counts.mid = randomNumber(6) / 2;
                  counts.down = randomNumber(8) + 1;
                  break;
                }

                var arr = ["up", "mid", "down"];
                for (var d in arr) {
                  var index = arr[d];
                  for (var i = 0; i <= counts[index]; i++) {
                    if (options[index]) {
                      result = result + soul[index][randomNumber(soul[index].length)];
                    }
                  }
                }
              }
              return result;
            };
            return heComes(text);
          }

          addProperty('stripColors', function() {
            return ("" + this).replace(/\u001b\[\d+m/g, '');
          });

        },

        "865b933cdca5bf49b1f012335b02ff93": // from: node_modules/testify/node_modules/colors/example.js
        function(exports, require, module, __filename, __dirname) {
          var colors = require('./colors');

          //colors.mode = "browser";

          var test = colors.red("hopefully colorless output");
          console.log('Rainbows are fun!'.rainbow);
          console.log('So '.italic + 'are'.underline + ' styles! '.bold + 'inverse'.inverse); // styles not widely supported
          console.log('Chains are also cool.'.bold.italic.underline.red); // styles not widely supported
          //console.log('zalgo time!'.zalgo);
          console.log(test.stripColors);
          console.log("a".grey + " b".black);

          console.log("Zebras are so fun!".zebra);

          console.log(colors.rainbow('Rainbows are fun!'));
          console.log(colors.italic('So ') + colors.underline('are') + colors.bold(' styles! ') + colors.inverse('inverse')); // styles not widely supported
          console.log(colors.bold(colors.italic(colors.underline(colors.red('Chains are also cool.'))))); // styles not widely supported
          //console.log(colors.zalgo('zalgo time!'));
          console.log(colors.stripColors(test));
          console.log(colors.grey("a") + colors.black(" b"));

          colors.addSequencer("america", function(letter, i, exploded) {
            if (letter === " ") return letter;
            switch (i % 3) {
            case 0:
              return letter.red;
            case 1:
              return letter.white;
            case 2:
              return letter.blue;
            }
          });

          colors.addSequencer("random", (function() {
            var available = ['bold', 'underline', 'italic', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];

            return function(letter, i, exploded) {
              return letter === " " ? letter : letter[available[Math.round(Math.random() * (available.length - 1))]];
            };
          })());

          console.log("AMERICA! F--K YEAH!".america);
          console.log("So apparently I've been to Mars, with all the little green men. But you know, I don't recall.".random);

          //
          // Custom themes
          //

          colors.setTheme({
            silly: 'rainbow',
            input: 'grey',
            verbose: 'cyan',
            prompt: 'grey',
            info: 'green',
            data: 'grey',
            help: 'cyan',
            warn: 'yellow',
            debug: 'blue',
            error: 'red'
          });

          // outputs red text
          console.log("this is an error".error);

          // outputs yellow text
          console.log("this is a warning".warn);



        },

        "c3451fe7035e99947143be3e88c3eaef": // from: node_modules/testify/node_modules/colors/test.js
        function(exports, require, module, __filename, __dirname) {
          var assert = require('assert'),
            colors = require('./colors');

          // 
          // This is a pretty nice example on how tests shouldn't be written. However,
          // it's more about API stability than about really testing it (although it's
          // a pretty complete test suite).
          //

          var s = 'string';

          function a(s, code) {
            return '\033[' + code.toString() + 'm' + s + '\033[39m';
          }

          function aE(s, color, code) {
            assert.equal(s[color], a(s, code));
            assert.equal(colors[color](s), a(s, code));
            assert.equal(s[color], colors[color](s));
            assert.equal(s[color].stripColors, s);
            assert.equal(s[color].stripColors, colors.stripColors(s));
          }

          function h(s, color) {
            return '<span style="color:' + color + ';">' + s + '</span>';
            // that's pretty dumb approach to testing it
          }

          var stylesColors = ['white', 'grey', 'black', 'blue', 'cyan', 'green', 'magenta', 'red', 'yellow'];
          var stylesAll = stylesColors.concat(['bold', 'italic', 'underline', 'inverse', 'rainbow']);

          colors.mode = 'console';
          assert.equal(s.bold, '\033[1m' + s + '\033[22m');
          assert.equal(s.italic, '\033[3m' + s + '\033[23m');
          assert.equal(s.underline, '\033[4m' + s + '\033[24m');
          assert.equal(s.inverse, '\033[7m' + s + '\033[27m');
          assert.ok(s.rainbow);
          aE(s, 'white', 37);
          aE(s, 'grey', 90);
          aE(s, 'black', 30);
          aE(s, 'blue', 34);
          aE(s, 'cyan', 36);
          aE(s, 'green', 32);
          aE(s, 'magenta', 35);
          aE(s, 'red', 31);
          aE(s, 'yellow', 33);
          assert.equal(s, 'string');

          colors.mode = 'browser';
          assert.equal(s.bold, '<b>' + s + '</b>');
          assert.equal(s.italic, '<i>' + s + '</i>');
          assert.equal(s.underline, '<u>' + s + '</u>');
          assert.equal(s.inverse, '<span style="background-color:black;color:white;">' + s + '</span>');
          assert.ok(s.rainbow);
          stylesColors.forEach(function(color) {
            assert.equal(s[color], h(s, color));
            assert.equal(colors[color](s), h(s, color));
          });

          colors.mode = 'none';
          stylesAll.forEach(function(style) {
            assert.equal(s[style], s);
            assert.equal(colors[style](s), s);
          });


        },

        "d7c4041289e5445eec291db26b21409d": // from: node_modules/testify/node_modules/minfinite/minfinite.js
        function(exports, require, module, __filename, __dirname) {
          // Generated by CoffeeScript 1.4.0
          (function() {
            var EventEmitter, FSM,
            __slice = [].slice;

            EventEmitter = require("events").EventEmitter;

            module.exports = FSM = (function() {

              function FSM(initial_state) {
                if (initial_state == null) {
                  initial_state = "START";
                }
                this.state = initial_state;
                this.emitter = new EventEmitter();
              }

              FSM.prototype.define = function(table) {
                if (this.validate(table)) {
                  return this.table = table;
                } else {
                  throw new Error("Invalid state table");
                }
              };

              FSM.prototype.validate = function(table) {
                var action, def, event, next, state, transition;
                for (state in table) {
                  def = table[state];
                  if (!(Object.keys(def).length > 0)) {
                    return false;
                  }
                  for (event in def) {
                    transition = def[event];
                    action = transition.action, next = transition.next;
                    if (typeof action !== "function") {
                      console.log("Action for " + state + ", " + event + " is not a function");
                      return false;
                    }
                    if (typeof next !== "string") {
                      console.log("Next state for " + state + ", " + event + " is not a string");
                      return false;
                    }
                    if (!table[next]) {
                      console.log("Next state for " + state + ", " + event + " does not exist");
                      return false;
                    }
                  }
                }
                return true;
              };

              FSM.prototype.event = function() {
                var action, args, current_state, name, next, transition;
                name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                current_state = this.state;
                transition = this.table[this.state][name];
                if (!transition) {
                  console.error("State(" + this.state + ") has no transition for Event(" + name + ")");
                } else {
                  action = transition.action, next = transition.next;
                  action.apply(null, args);
                  this.state = next;
                }
                if (this.state !== current_state) {
                  return this.emitter.emit(this.state);
                }
              };

              return FSM;

            })();

          }).call(this);

        },

        "1f082de170804a1f8caa134abdafdb55": // from: node_modules/testify/src/context.coffee
        function(exports, require, module, __filename, __dirname) {
          var Context, EventEmitter, FSM,
          __slice = [].slice;

          EventEmitter = require("events").EventEmitter;

          FSM = require("minfinite");

          module.exports = Context = (function() {

            function Context(name, work, parent) {
              var _this = this;
              this.name = name;
              this.work = work;
              this.parent = parent;
              if (this.work.length === 0) {
                this.type = "sync";
              } else {
                this.type = "async";
              }
              if (this.parent) {
                this.level = this.parent.level + 1;
              } else {
                this.level = 0;
              }
              this.children = [];
              this.emitter = new EventEmitter();
              this.fsm = new FSM();
              this.fsm.define({
                START: {
                  sync_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "SYNC"
                  },
                  async_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "ASYNC"
                  },
                  childless: {
                    action: function() {},
                    next: "CHILDLESS"
                  },
                  end_of_block: {
                    action: function() {
                      return _this.notify_parent();
                    },
                    next: "COMPLETE"
                  }
                },
                SYNC: {
                  sync_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "SYNC"
                  },
                  async_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "ASYNC"
                  },
                  end_of_block: {
                    action: function() {
                      return _this.notify_parent();
                    },
                    next: "COMPLETE"
                  },
                  completion: {
                    action: function() {
                      return _this.notify_parent();
                    },
                    next: "COMPLETE"
                  }
                },
                ASYNC: {
                  sync_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "ASYNC"
                  },
                  async_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "ASYNC"
                  },
                  end_of_block: {
                    action: function() {},
                    next: "ASYNC"
                  },
                  completion: {
                    action: function() {
                      return _this.notify_parent();
                    },
                    next: "COMPLETE"
                  }
                },
                CHILDLESS: {
                  sync_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "SYNC"
                  },
                  async_child: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "ASYNC"
                  },
                  completion: {
                    action: function() {
                      return _this.notify_parent();
                    },
                    next: "COMPLETE"
                  }
                },
                COMPLETE: {
                  sync_child: {
                    action: function() {
                      throw new Error("Context '" + _this.name + "' created a synchronous child after it had completed");
                    },
                    next: "COMPLETE"
                  },
                  completion: {
                    action: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    },
                    next: "COMPLETE"
                  },
                  reset: {
                    action: function() {},
                    next: "START"
                  }
                }
              });
            }

            Context.prototype.state = function() {
              return this.fsm.state;
            };

            Context.prototype.event = function() {
              var args, name, _ref;
              name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
              return (_ref = this.fsm).event.apply(_ref, [name].concat(__slice.call(args)));
            };

            Context.prototype.is_done = function() {
              return this.children.every(function(child) {
                return child.state() === "COMPLETE";
              });
            };

            Context.prototype.notify_parent = function() {
              var _this = this;
              return setTimeout((function() {
                var _ref, _ref1;
                if ((_ref = _this.parent) != null ? _ref.is_done() : void 0) {
                  return (_ref1 = _this.parent) != null ? _ref1.event("completion", _this) : void 0;
                }
              }), 0);
            };

            Context.prototype.done = function() {
              return this.event("completion");
            };

            Context.prototype.child = function(description, work) {
              var child;
              child = new this.constructor(description, work, this);
              if (child.type === "sync") {
                this.event("sync_child", child);
              } else if (child.type === "async") {
                this.event("async_child", child);
              } else {
                throw new Error("bad type: " + child.type);
              }
              this.children.push(child);
              this.emitter.emit("child", child);
              return child._run();
            };

            Context.prototype._run = function() {
              var args;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              this.work(this);
              if (this.type === "sync" || this.children.length > 0) {
                return this.event("end_of_block");
              } else {
                return this.event("childless");
              }
            };

            return Context;

          })();

        },

        "7abe6dc3c91fe653e9c4a2d096ee8684": // from: node_modules/testify/src/reporters.coffee
        function(exports, require, module, __filename, __dirname) {
          var ConsoleReporter, DOMReporter;

          ConsoleReporter = (function() {

            function ConsoleReporter() {}

            ConsoleReporter.prototype.add_suite = function(suite) {
              var _this = this;
              suite.emitter.on("child", function(child) {
                return _this.hook(child);
              });
              suite.fsm.emitter.on("COMPLETE", function() {
                return _this.report_suite(suite);
              });
              return process.on("exit", function() {
                return _this.report_suite(suite);
              });
            };

            ConsoleReporter.prototype.hook = function(child) {
              var _this = this;
              child.emitter.on("child", function(context) {
                return _this.hook(context);
              });
              return child.emitter.on("status", function(status) {
                return _this.status(status);
              });
            };

            ConsoleReporter.prototype.status = function(type) {
              var abbrev;
              if (abbrev = this.abbreviation[type]) {
                return process.stdout.write(this.colorize(type, abbrev));
              }
            };

            ConsoleReporter.prototype.abbreviation = {
              pass: ".",
              incomplete: "I",
              failure: "F",
              error: "E"
            };

            ConsoleReporter.prototype.report_suite = function(suite) {
              var level, result, test, _i, _len;
              if (suite._reported) {
                return;
              } else {
                suite._reported = true;
              }
              if (suite.failed) {
                suite.name = "" + suite.name + " (FAILED)";
              } else {
                suite.name = "" + suite.name + " (PASSED)";
              }
              result = [];
              this.collect(suite, result);
              for (_i = 0, _len = result.length; _i < _len; _i++) {
                test = result[_i];
                level = test.level;
                if (test.state() !== "COMPLETE") {
                  this.result("" + test.name + " ( incomplete )", {
                    type: "incomplete",
                    level: level
                  });
                } else if (test.failed === false) {
                  this.result(test.name, {
                    type: "pass",
                    level: level
                  });
                } else if (test.failed.constructor === String || test.failed.name === "AssertionError") {
                  this.result("" + test.name + " ( " + (test.failed.toString()) + " )", {
                    type: "failure",
                    level: level,
                    stack: test.failed.stack
                  });
                } else {
                  this.result("" + test.name + " ( " + (test.failed.toString()) + " )", {
                    type: "error",
                    level: level,
                    stack: test.failed.stack
                  });
                }
              }
              if (suite.failed && process.exit) {
                return process.exit(1);
              }
            };

            ConsoleReporter.prototype.collect = function(context, array) {
              var item, _i, _len, _ref, _results;
              if (array == null) {
                array = [];
              }
              array.push(context);
              _ref = context.children;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                _results.push(this.collect(item, array));
              }
              return _results;
            };

            ConsoleReporter.prototype.result = function(string, options) {
              var level, match, regex, space, where;
              if (options == null) {
                options = {};
              }
              if (!this._receiving_results) {
                console.log();
                this._receiving_results = true;
              }
              if (options.type) {
                string = this.colorize(options.type, string);
              }
              if (level = options.level) {
                space = "";
                while (level--) {
                  space = space + "    ";
                }
                string = space + string;
              }
              console.log(string);
              if (options.stack) {
                where = options.stack.split("\n")[1];
                regex = /\((.*)\)/;
                match = regex.exec(where);
                try {
                  return console.log(space + match[1]);
                } catch (error) {
                  return console.log(space + where.slice(7));
                }
              }
            };

            ConsoleReporter.prototype.colorize = function(type, string) {
              var color;
              if (color = this.color_map[type]) {
                return string[color];
              } else {
                return string;
              }
            };

            ConsoleReporter.prototype.color_map = {
              pass: "green",
              incomplete: "magenta",
              failure: "red",
              error: "yellow"
            };

            return ConsoleReporter;

          })();

          DOMReporter = (function() {

            function DOMReporter(id, options) {
              if (options == null) {
                options = {};
              }
              this.timeout = options.timeout || 2000;
              this.root = document.getElementById(id);
              this.suites = [];
            }

            DOMReporter.prototype.add_suite = function(suite) {
              var _this = this;
              this.suite_dom(suite);
              suite.emitter.on("child", function(child) {
                return _this.handle_child(suite, child);
              });
              suite.fsm.emitter.on("COMPLETE", function() {
                return _this.report_suite(suite);
              });
              return setTimeout((function() {
                return _this.report_suite(suite);
              }), this.timeout);
            };

            DOMReporter.prototype.handle_child = function(suite, child) {
              var _this = this;
              this.test_dom(child);
              child.emitter.on("child", function(context) {
                return _this.handle_child(suite, context);
              });
              return child.emitter.on("status", function(status) {
                return _this.status(suite, child, status);
              });
            };

            DOMReporter.prototype.report_suite = function(suite) {
              var level, test, tests, _i, _j, _len, _len1, _ref, _results;
              if (suite._reported) {
                return;
              } else {
                suite._reported = true;
              }
              if (suite.state() !== "COMPLETE") {
                suite._html.title.classList.add("incomplete");
              } else if (suite.failed === false) {
                suite._html.title.classList.add("pass");
              } else {
                suite._html.title.classList.add("failed");
              }
              tests = [];
              _ref = suite.children;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                test = _ref[_i];
                this.collect(test, tests);
              }
              _results = [];
              for (_j = 0, _len1 = tests.length; _j < _len1; _j++) {
                test = tests[_j];
                level = test.level;
                if (test.state() !== "COMPLETE") {
                  _results.push(this.result(test, {
                    type: "incomplete"
                  }));
                } else if (test.failed === false) {
                  _results.push(this.result(test, {
                    type: "pass"
                  }));
                } else if (test.failed.constructor === String || test.failed.name === "AssertionError") {
                  _results.push(this.result(test, {
                    type: "failure",
                    stack: test.failed.stack
                  }));
                } else {
                  _results.push(this.result(test, {
                    type: "error",
                    stack: test.failed.stack
                  }));
                }
              }
              return _results;
            };

            DOMReporter.prototype.collect = function(context, array) {
              var item, _i, _len, _ref;
              if (array == null) {
                array = [];
              }
              array.push(context);
              _ref = context.children;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                this.collect(item, array);
              }
              return array;
            };

            DOMReporter.prototype.suite_dom = function(suite) {
              var main, tests, title, _ref;
              suite._html = {
                main: document.createElement("div"),
                title: document.createElement("h3"),
                tests: document.createElement("ul")
              };
              _ref = suite._html, main = _ref.main, tests = _ref.tests, title = _ref.title;
              main.classList.add("testify_suite");
              title.textContent = suite.name;
              main.appendChild(title);
              main.appendChild(tests);
              return this.root.appendChild(main);
            };

            DOMReporter.prototype.test_dom = function(test) {
              var span, tests;
              test._html = {
                name: document.createElement("li")
              };
              test._html.name.classList.add("testify_test");
              span = document.createElement("span");
              span.classList.add("testify_test_name");
              span.textContent = test.name;
              test._html.name.appendChild(span);
              if (test.parent._html.tests) {

              } else {
                tests = test.parent._html.tests = document.createElement("ul");
                test.parent._html.name.appendChild(tests);
              }
              return test.parent._html.tests.appendChild(test._html.name);
            };

            DOMReporter.prototype.status = function(suite, test, type) {
              var fn,
              _this = this;
              fn = function() {
                var element, match, regex, span, stacky, where;
                element = test._html.name;
                span = element.children[0];
                span.classList.add(type);
                if (type === "failure" || type === "error") {
                  span.textContent = span.textContent + (" (" + (test.failed.toString()) + ")");
                  stacky = document.createElement("pre");
                  where = test.failed.stack.split("\n")[1];
                  regex = /\((.*)\)/;
                  match = regex.exec(where);
                  try {
                    stacky.textContent = match[1];
                  } catch (error) {
                    stacky.textContent = where.slice(7);
                  }
                  stacky.classList.add("stack");
                  return element.insertBefore(stacky, span.nextSibling);
                } else if (type === "incomplete") {
                  return span.textContent = span.textContent + " (incomplete)";
                }
              };
              return setTimeout(fn, 50);
            };

            DOMReporter.prototype.result = function(test, options) {
              var element, span, type_string;
              if (test.children.length > 0 || options.type === "incomplete") {
                element = test._html.name;
                if (options.type) {
                  span = element.children[0];
                  span.classList.add(options.type);
                  type_string = " (" + options.type + ")";
                  if (options.type === "failure") {
                    return span.textContent = span.textContent + (" (" + (test.failed.toString()) + ")");
                  } else if (options.type === "incomplete") {
                    return span.textContent = span.textContent + " (incomplete)";
                  }
                }
              }
            };

            return DOMReporter;

          })();

          module.exports = {
            ConsoleReporter: ConsoleReporter,
            DOMReporter: DOMReporter
          };

        },

        "62e49fef2333868ff4848cf4ec8f121d": // from: node_modules/testify/src/test.coffee
        function(exports, require, module, __filename, __dirname) {
          var Context, TestContext, colors,
          __hasProp = {}.hasOwnProperty,
            __extends = function(child, parent) {
              for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            },
            __slice = [].slice;

          colors = require("colors");

          Context = require("./context");

          module.exports = TestContext = (function(_super) {

            __extends(TestContext, _super);

            function TestContext() {
              var args;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              TestContext.__super__.constructor.apply(this, args);
              this.failed = false;
            }

            TestContext.prototype.test = function(description, work) {
              return this.child(description, work);
            };

            TestContext.prototype.run = function() {
              TestContext.reporter.add_suite(this);
              return this._run();
            };

            TestContext.prototype._run = function() {
              var _this = this;
              this.fsm.emitter.once("COMPLETE", function() {
                if (_this.timeout_id) {
                  clearTimeout(_this.timeout_id);
                }
                return _this.timeout_id = void 0;
              });
              try {
                TestContext.__super__._run.call(this);
                if (this.type === "sync") {
                  return this.status("pass", ".");
                }
              } catch (error) {
                this.fail(error);
                return this.event("end_of_block");
              }
            };

            TestContext.prototype.status = function(type) {
              return this.emitter.emit("status", type);
            };

            TestContext.prototype.pass = function() {
              if (!this.failed) {
                this.status("pass");
                return this.done();
              }
            };

            TestContext.prototype.fail = function(error) {
              var message, throwaway;
              if (error.constructor === String) {
                this.status("failure");
                throwaway = new Error(error);
                message = error.toString();
                error = {
                  name: "AssertionError",
                  stack: throwaway.stack.split("\n").slice(1).join("\n"),
                  toString: function() {
                    return message;
                  }
                };
              } else if (error.name === "AssertionError") {
                this.status("failure");
              } else {
                this.status("error");
              }
              if (this.type === "async") {
                this.event("completion");
              }
              return this.propagate_failure(error);
            };

            TestContext.prototype.timeout = function(milliseconds, message) {
              var fn,
              _this = this;
              fn = function() {
                return _this.fail(message || ("Timed out after " + milliseconds + " milliseconds"));
              };
              return this.timeout_id = setTimeout(fn, milliseconds);
            };

            TestContext.prototype.propagate_failure = function(error) {
              var _ref;
              this.failed = error;
              return (_ref = this.parent) != null ? _ref.propagate_failure("subtest failures") : void 0;
            };

            return TestContext;

          })(Context);

        },

        "1acd0107c78da6657c2d635a044b63b7": // from: node_modules/testify/src/testify.coffee
        function(exports, require, module, __filename, __dirname) {
          var Context, EventEmitter, TestContext, TestOutput, Testify, colors,
          __slice = [].slice;

          colors = require("colors");

          EventEmitter = require("events").EventEmitter;

          Context = require("./context");

          TestOutput = (function() {

            function TestOutput() {
              console.log();
            }

            TestOutput.prototype.status = function(type, string) {
              return process.stdout.write(this.colorize(type, string));
            };

            TestOutput.prototype.result = function(string, options) {
              var level, match, regex, space, where;
              if (options == null) {
                options = {};
              }
              if (!this._receiving_results) {
                console.log();
                this._receiving_results = true;
              }
              if (options.type) {
                string = this.colorize(options.type, string);
              }
              if (level = options.level) {
                space = "";
                while (level--) {
                  space = space + "    ";
                }
                string = space + string;
              }
              console.log(string);
              if (options.stack) {
                where = options.stack.split("\n")[1];
                regex = /\((.*)\)/;
                match = regex.exec(where);
                try {
                  return console.log(space + match[1]);
                } catch (error) {
                  return console.log(space + where.slice(7));
                }
              }
            };

            TestOutput.prototype.colorize = function(type, string) {
              var color;
              if (Testify.options.color && (color = this.color_map[type])) {
                return string[color];
              } else {
                return string;
              }
            };

            TestOutput.prototype.color_map = {
              pass: "green",
              incomplete: "magenta",
              failure: "red",
              error: "yellow"
            };

            return TestOutput;

          })();

          TestContext = require("./test");

          Testify = {
            ConsoleReporter: require("./reporters").ConsoleReporter,
            DOMReporter: require("./reporters").DOMReporter,
            TestContext: TestContext,
            count: 0,
            emitter: new EventEmitter(),
            once: function() {
              var args, _ref;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              return (_ref = Testify.emitter).once.apply(_ref, args);
            },
            options: {
              color: true
            },
            test: function(name, fn) {
              var suite;
              TestContext.options = Testify.options;
              TestContext.reporter = Testify.reporter || new Testify.ConsoleReporter();
              suite = new TestContext(name, fn);
              Testify.count++;
              suite.emitter.once("COMPLETE", function() {
                Testify.count--;
                if (Testify.count === 0) {
                  return Testify.emitter.emit("done");
                }
              });
              return suite.run();
            },
            benchmark: function(name, fn) {
              var Benchmark;
              Benchmark = require("./benchmark");
              return new Benchmark(name, fn);
            }
          };

          module.exports = Testify;

        },

        "c4f9141dbd0d7a4e3dd3d1dc0a64c667": // from: 
        function(exports, require, module, __filename, __dirname) {
          // http://wiki.commonjs.org/wiki/Unit_Testing/1.0
          //
          // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
          //
          // Originally from narwhal.js (http://narwhaljs.org)
          // Copyright (c) 2009 Thomas Robinson <280north.com>
          //
          // Permission is hereby granted, free of charge, to any person obtaining a copy
          // of this software and associated documentation files (the 'Software'), to
          // deal in the Software without restriction, including without limitation the
          // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
          // sell copies of the Software, and to permit persons to whom the Software is
          // furnished to do so, subject to the following conditions:
          //
          // The above copyright notice and this permission notice shall be included in
          // all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
          // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
          // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

          // UTILITY
          var util = require('util');
          var pSlice = Array.prototype.slice;

          // 1. The assert module provides functions that throw
          // AssertionError's when particular conditions are not met. The
          // assert module must conform to the following interface.

          var assert = module.exports = ok;

          // 2. The AssertionError is defined in assert.
          // new assert.AssertionError({ message: message,
          //                             actual: actual,
          //                             expected: expected })

          assert.AssertionError = function AssertionError(options) {
            this.name = 'AssertionError';
            this.message = options.message;
            this.actual = options.actual;
            this.expected = options.expected;
            this.operator = options.operator;
            var stackStartFunction = options.stackStartFunction || fail;

            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, stackStartFunction);
            }
          };

          // assert.AssertionError instanceof Error
          util.inherits(assert.AssertionError, Error);

          function replacer(key, value) {
            if (value === undefined) {
              return '' + value;
            }
            if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
              return value.toString();
            }
            if (typeof value === 'function' || value instanceof RegExp) {
              return value.toString();
            }
            return value;
          }

          function truncate(s, n) {
            if (typeof s == 'string') {
              return s.length < n ? s : s.slice(0, n);
            } else {
              return s;
            }
          }

          assert.AssertionError.prototype.toString = function() {
            if (this.message) {
              return [this.name + ':', this.message].join(' ');
            } else {
              return [
              this.name + ':',
              truncate(JSON.stringify(this.actual, replacer), 128),
              this.operator,
              truncate(JSON.stringify(this.expected, replacer), 128)].join(' ');
            }
          };

          // At present only the three keys mentioned above are used and
          // understood by the spec. Implementations or sub modules can pass
          // other keys to the AssertionError's constructor - they will be
          // ignored.

          // 3. All of the following functions must throw an AssertionError
          // when a corresponding condition is not met, with a message that
          // may be undefined if not provided.  All assertion methods provide
          // both the actual and expected values to the assertion error for
          // display purposes.

          function fail(actual, expected, message, operator, stackStartFunction) {
            throw new assert.AssertionError({
              message: message,
              actual: actual,
              expected: expected,
              operator: operator,
              stackStartFunction: stackStartFunction
            });
          }

          // EXTENSION! allows for well behaved errors defined elsewhere.
          assert.fail = fail;

          // 4. Pure assertion tests whether a value is truthy, as determined
          // by !!guard.
          // assert.ok(guard, message_opt);
          // This statement is equivalent to assert.equal(true, !!guard,
          // message_opt);. To test strictly for the value true, use
          // assert.strictEqual(true, guard, message_opt);.

          function ok(value, message) {
            if ( !! !value) fail(value, true, message, '==', assert.ok);
          }
          assert.ok = ok;

          // 5. The equality assertion tests shallow, coercive equality with
          // ==.
          // assert.equal(actual, expected, message_opt);

          assert.equal = function equal(actual, expected, message) {
            if (actual != expected) fail(actual, expected, message, '==', assert.equal);
          };

          // 6. The non-equality assertion tests for whether two objects are not equal
          // with != assert.notEqual(actual, expected, message_opt);

          assert.notEqual = function notEqual(actual, expected, message) {
            if (actual == expected) {
              fail(actual, expected, message, '!=', assert.notEqual);
            }
          };

          // 7. The equivalence assertion tests a deep equality relation.
          // assert.deepEqual(actual, expected, message_opt);

          assert.deepEqual = function deepEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected)) {
              fail(actual, expected, message, 'deepEqual', assert.deepEqual);
            }
          };

          function _deepEqual(actual, expected) {
            // 7.1. All identical values are equivalent, as determined by ===.
            if (actual === expected) {
              return true;

            } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
              if (actual.length != expected.length) return false;

              for (var i = 0; i < actual.length; i++) {
                if (actual[i] !== expected[i]) return false;
              }

              return true;

              // 7.2. If the expected value is a Date object, the actual value is
              // equivalent if it is also a Date object that refers to the same time.
            } else if (actual instanceof Date && expected instanceof Date) {
              return actual.getTime() === expected.getTime();

              // 7.3 If the expected value is a RegExp object, the actual value is
              // equivalent if it is also a RegExp object with the same source and
              // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
            } else if (actual instanceof RegExp && expected instanceof RegExp) {
              return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

              // 7.4. Other pairs that do not both pass typeof value == 'object',
              // equivalence is determined by ==.
            } else if (typeof actual != 'object' && typeof expected != 'object') {
              return actual == expected;

              // 7.5 For all other Object pairs, including Array objects, equivalence is
              // determined by having the same number of owned properties (as verified
              // with Object.prototype.hasOwnProperty.call), the same set of keys
              // (although not necessarily the same order), equivalent values for every
              // corresponding key, and an identical 'prototype' property. Note: this
              // accounts for both named and indexed properties on Arrays.
            } else {
              return objEquiv(actual, expected);
            }
          }

          function isUndefinedOrNull(value) {
            return value === null || value === undefined;
          }

          function isArguments(object) {
            return Object.prototype.toString.call(object) == '[object Arguments]';
          }

          function objEquiv(a, b) {
            if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
            // an identical 'prototype' property.
            if (a.prototype !== b.prototype) return false;
            //~~~I've managed to break Object.keys through screwy arguments passing.
            //   Converting to array solves the problem.
            if (isArguments(a)) {
              if (!isArguments(b)) {
                return false;
              }
              a = pSlice.call(a);
              b = pSlice.call(b);
              return _deepEqual(a, b);
            }
            try {
              var ka = Object.keys(a),
                kb = Object.keys(b),
                key, i;
            } catch (e) { //happens when one is a string literal and the other isn't
              return false;
            }
            // having the same number of owned properties (keys incorporates
            // hasOwnProperty)
            if (ka.length != kb.length) return false;
            //the same set of keys (although not necessarily the same order),
            ka.sort();
            kb.sort();
            //~~~cheap key test
            for (i = ka.length - 1; i >= 0; i--) {
              if (ka[i] != kb[i]) return false;
            }
            //equivalent values for every corresponding key, and
            //~~~possibly expensive deep test
            for (i = ka.length - 1; i >= 0; i--) {
              key = ka[i];
              if (!_deepEqual(a[key], b[key])) return false;
            }
            return true;
          }

          // 8. The non-equivalence assertion tests for any deep inequality.
          // assert.notDeepEqual(actual, expected, message_opt);

          assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
            if (_deepEqual(actual, expected)) {
              fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
            }
          };

          // 9. The strict equality assertion tests strict equality, as determined by ===.
          // assert.strictEqual(actual, expected, message_opt);

          assert.strictEqual = function strictEqual(actual, expected, message) {
            if (actual !== expected) {
              fail(actual, expected, message, '===', assert.strictEqual);
            }
          };

          // 10. The strict non-equality assertion tests for strict inequality, as
          // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

          assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
            if (actual === expected) {
              fail(actual, expected, message, '!==', assert.notStrictEqual);
            }
          };

          function expectedException(actual, expected) {
            if (!actual || !expected) {
              return false;
            }

            if (expected instanceof RegExp) {
              return expected.test(actual);
            } else if (actual instanceof expected) {
              return true;
            } else if (expected.call({}, actual) === true) {
              return true;
            }

            return false;
          }

          function _throws(shouldThrow, block, expected, message) {
            var actual;

            if (typeof expected === 'string') {
              message = expected;
              expected = null;
            }

            try {
              block();
            } catch (e) {
              actual = e;
            }

            message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

            if (shouldThrow && !actual) {
              fail(actual, expected, 'Missing expected exception' + message);
            }

            if (!shouldThrow && expectedException(actual, expected)) {
              fail(actual, expected, 'Got unwanted exception' + message);
            }

            if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {
              throw actual;
            }
          }

          // 11. Expected to throw an error:
          // assert.throws(block, Error_opt, message_opt);

          assert.throws = function(block, /*optional*/ error, /*optional*/ message) {
            _throws.apply(this, [true].concat(pSlice.call(arguments)));
          };

          // EXTENSION! This is annoying to write outside this module.
          assert.doesNotThrow = function(block, /*optional*/ message) {
            _throws.apply(this, [false].concat(pSlice.call(arguments)));
          };

          assert.ifError = function(err) {
            if (err) {
              throw err;
            }
          };

        },

        "b499eb63a89b9e6fb99ef1209a65ace6": // from: 
        function(exports, require, module, __filename, __dirname) {
          if (!process.EventEmitter) process.EventEmitter = function() {};

          var EventEmitter = exports.EventEmitter = process.EventEmitter;
          var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(xs) {
              return Object.prototype.toString.call(xs) === '[object Array]'
            };

          // By default EventEmitters will print a warning if more than
          // 10 listeners are added to it. This is a useful default which
          // helps finding memory leaks.
          //
          // Obviously not all Emitters should be limited to 10. This function allows
          // that to be increased. Set to zero for unlimited.
          var defaultMaxListeners = 10;
          EventEmitter.prototype.setMaxListeners = function(n) {
            if (!this._events) this._events = {};
            this._events.maxListeners = n;
          };


          EventEmitter.prototype.emit = function(type) {
            // If there is no 'error' event listener then throw.
            if (type === 'error') {
              if (!this._events || !this._events.error || (isArray(this._events.error) && !this._events.error.length)) {
                if (arguments[1] instanceof Error) {
                  throw arguments[1]; // Unhandled 'error' event
                } else {
                  throw new Error("Uncaught, unspecified 'error' event.");
                }
                return false;
              }
            }

            if (!this._events) return false;
            var handler = this._events[type];
            if (!handler) return false;

            if (typeof handler == 'function') {
              switch (arguments.length) {
                // fast cases
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
                // slower
              default:
                var args = Array.prototype.slice.call(arguments, 1);
                handler.apply(this, args);
              }
              return true;

            } else if (isArray(handler)) {
              var args = Array.prototype.slice.call(arguments, 1);

              var listeners = handler.slice();
              for (var i = 0, l = listeners.length; i < l; i++) {
                listeners[i].apply(this, args);
              }
              return true;

            } else {
              return false;
            }
          };

          // EventEmitter is defined in src/node_events.cc
          // EventEmitter.prototype.emit() is also defined there.
          EventEmitter.prototype.addListener = function(type, listener) {
            if ('function' !== typeof listener) {
              throw new Error('addListener only takes instances of Function');
            }

            if (!this._events) this._events = {};

            // To avoid recursion in the case that type == "newListeners"! Before
            // adding it to the listeners, first emit "newListeners".
            this.emit('newListener', type, listener);

            if (!this._events[type]) {
              // Optimize the case of one listener. Don't need the extra array object.
              this._events[type] = listener;
            } else if (isArray(this._events[type])) {

              // Check for listener leak
              if (!this._events[type].warned) {
                var m;
                if (this._events.maxListeners !== undefined) {
                  m = this._events.maxListeners;
                } else {
                  m = defaultMaxListeners;
                }

                if (m && m > 0 && this._events[type].length > m) {
                  this._events[type].warned = true;
                  console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.',
                  this._events[type].length);
                  console.trace();
                }
              }

              // If we've already got an array, just append.
              this._events[type].push(listener);
            } else {
              // Adding the second element, need to change to array.
              this._events[type] = [this._events[type], listener];
            }

            return this;
          };

          EventEmitter.prototype.on = EventEmitter.prototype.addListener;

          EventEmitter.prototype.once = function(type, listener) {
            var self = this;
            self.on(type, function g() {
              self.removeListener(type, g);
              listener.apply(this, arguments);
            });

            return this;
          };

          EventEmitter.prototype.removeListener = function(type, listener) {
            if ('function' !== typeof listener) {
              throw new Error('removeListener only takes instances of Function');
            }

            // does not use listeners(), so no side effect of creating _events[type]
            if (!this._events || !this._events[type]) return this;

            var list = this._events[type];

            if (isArray(list)) {
              var i = list.indexOf(listener);
              if (i < 0) return this;
              list.splice(i, 1);
              if (list.length == 0) delete this._events[type];
            } else if (this._events[type] === listener) {
              delete this._events[type];
            }

            return this;
          };

          EventEmitter.prototype.removeAllListeners = function(type) {
            // does not use listeners(), so no side effect of creating _events[type]
            if (type && this._events && this._events[type]) this._events[type] = null;
            return this;
          };

          EventEmitter.prototype.listeners = function(type) {
            if (!this._events) this._events = {};
            if (!this._events[type]) this._events[type] = [];
            if (!isArray(this._events[type])) {
              this._events[type] = [this._events[type]];
            }
            return this._events[type];
          };

        },

        "4b089ad1310f754af3510dd2da9a1ff7": // from: 
        function(exports, require, module, __filename, __dirname) {
          var Stat, base64Decode, fs, getFile;

          getFile = function(path) {
            var file, part, parts, _i, _len;
            parts = path.split("/").slice(1);
            file = global.filesystem.root;
            for (_i = 0, _len = parts.length; _i < _len; _i++) {
              part = parts[_i];
              if (!(file = file[part])) {
                throw "File not found at '" + path + "'";
              }
            }
            return file;
          };

          Stat = (function() {

            function Stat(path) {
              this.file = getFile(path);
            }

            Stat.prototype.isDirectory = function() {
              return this.file.__stat.type === "directory";
            };

            Stat.prototype.isFile = function() {
              return this.file.__stat.type === "file";
            };

            Stat.prototype.isSymbolicLink = function() {
              return false;
            };

            return Stat;

          })();

          base64Decode = function(string) {
            return decodeURIComponent(escape(window.atob(string)));
          };

          var fs = {
            readFileSync: function(path, encoding) {
              var file;
              file = getFile(path);
              return global.filesystem.read(file);
            },
            statSync: function(path) {
              return new Stat(path);
            },
            lstatSync: function(path) {
              return this.statSync(path);
            },
            // realpath Sync adapted from Node source
            realpathSync: function realpathSync(p, cache) {

              var isWindows = process.platform === 'win32';

              // Regexp that finds the next partion of a (partial) path
              // result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
              if (isWindows) {
                var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
              } else {
                var nextPartRe = /(.*?)(?:[\/]+|$)/g;
              }

              // Regex to find the device root, including trailing slash. E.g. 'c:\\'.
              if (isWindows) {
                var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
              } else {
                var splitRootRe = /^[\/]*/;
              }

              var pathModule = NativeModule.require("path");
              var normalize = pathModule.normalize;

              // make p is absolute
              p = pathModule.resolve(p);

              if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
                return cache[p];
              }

              var original = p,
                seenLinks = {},
                knownHard = {};

              // current character position in p
              var pos;
              // the partial path so far, including a trailing slash if any
              var current;
              // the partial path without a trailing slash (except when pointing at a root)
              var base;
              // the partial path scanned in the previous round, with slash
              var previous;

              start();

              function start() {
                // Skip over roots
                var m = splitRootRe.exec(p);
                pos = m[0].length;
                current = m[0];
                base = m[0];
                previous = '';

                // On windows, check that the root exists. On unix there is no need.
                if (isWindows && !knownHard[base]) {
                  fs.lstatSync(base);
                  knownHard[base] = true;
                }
              }

              // walk down the path, swapping out linked pathparts for their real
              // values
              // NB: p.length changes.
              while (pos < p.length) {
                // find the next part
                nextPartRe.lastIndex = pos;
                var result = nextPartRe.exec(p);
                previous = current;
                current += result[0];
                base = previous + result[1];
                pos = nextPartRe.lastIndex;

                // continue if not a symlink
                if (knownHard[base] || (cache && cache[base] === base)) {
                  continue;
                }

                var resolvedLink;
                if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
                  // some known symbolic link.  no need to stat again.
                  resolvedLink = cache[base];
                } else {
                  var stat = fs.lstatSync(base);
                  if (!stat.isSymbolicLink()) {
                    knownHard[base] = true;
                    if (cache) cache[base] = base;
                    continue;
                  }

                  // read the link if it wasn't read before
                  // dev/ino always return 0 on windows, so skip the check.
                  var linkTarget = null;
                  if (!isWindows) {
                    var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
                    if (seenLinks.hasOwnProperty(id)) {
                      linkTarget = seenLinks[id];
                    }
                  }
                  if (linkTarget === null) {
                    fs.statSync(base);
                    linkTarget = fs.readlinkSync(base);
                  }
                  resolvedLink = pathModule.resolve(previous, linkTarget);
                  // track this, if given a cache.
                  if (cache) cache[base] = resolvedLink;
                  if (!isWindows) seenLinks[id] = linkTarget;
                }

                // resolve the link, then start over
                p = pathModule.resolve(resolvedLink, p.slice(pos));
                start();
              }

              if (cache) cache[original] = p;

              return p;
            }
          };

          module.exports = fs;
        },

        "223f09f17e4aff9f2d05493c688f7934": // from: 
        function(exports, require, module, __filename, __dirname) {
          //
          // Adapted from Node source
          //

          var NativeModule = require('native_module');
          var Script = process.binding('evals').NodeScript;
          var runInThisContext = Script.runInThisContext;
          var runInNewContext = Script.runInNewContext;
          var assert = require('assert').ok;


          // If obj.hasOwnProperty has been overridden, then calling
          // obj.hasOwnProperty(prop) will break.
          // See: https://github.com/joyent/node/issues/1707
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }


          function Module(id, parent) {
            this.id = id;
            this.exports = {};
            this.parent = parent;
            if (parent && parent.children) {
              parent.children.push(this);
            }

            this.filename = null;
            this.loaded = false;
            this.children = [];
          }
          module.exports = Module;

          // Set the environ variable NODE_MODULE_CONTEXTS=1 to make node load all
          // modules in thier own context.
          Module._contextLoad = (+process.env['NODE_MODULE_CONTEXTS'] > 0);
          Module._cache = {};
          Module._pathCache = {};
          Module._extensions = {};
          var modulePaths = [];
          Module.globalPaths = [];

          Module.wrapper = NativeModule.wrapper;
          Module.wrap = NativeModule.wrap;

          var path = NativeModule.require('path');

          Module._debug = function() {};
          if (process.env.NODE_DEBUG && /module/.test(process.env.NODE_DEBUG)) {
            Module._debug = function(x) {
              console.error(x);
            };
          }


          // We use this alias for the preprocessor that filters it out
          var debug = Module._debug;


          // given a module name, and a list of paths to test, returns the first
          // matching file in the following precedence.
          //
          // require("a.<ext>")
          //   -> a.<ext>
          //
          // require("a")
          //   -> a
          //   -> a.<ext>
          //   -> a/index.<ext>

          function statPath(path) {
            var fs = NativeModule.require('fs');
            try {
              return fs.statSync(path);
            } catch (ex) {}
            return false;
          }

          // check if the directory is a package.json dir
          var packageCache = {};

          function readPackage(requestPath) {
            if (hasOwnProperty(packageCache, requestPath)) {
              return packageCache[requestPath];
            }

            var fs = NativeModule.require('fs');
            try {
              var jsonPath = path.resolve(requestPath, 'package.json');
              var json = fs.readFileSync(jsonPath, 'utf8');
            } catch (e) {
              return false;
            }

            try {
              var pkg = packageCache[requestPath] = JSON.parse(json);
            } catch (e) {
              e.path = jsonPath;
              e.message = 'Error parsing ' + jsonPath + ': ' + e.message;
              throw e;
            }
            return pkg;
          }

          function tryPackage(requestPath, exts) {
            var pkg = readPackage(requestPath);

            if (!pkg || !pkg.main) return false;

            var filename = path.resolve(requestPath, pkg.main);
            return tryFile(filename) || tryExtensions(filename, exts) || tryExtensions(path.resolve(filename, 'index'), exts);
          }

          // In order to minimize unnecessary lstat() calls,
          // this cache is a list of known-real paths.
          // Set to an empty object to reset.
          Module._realpathCache = {};

          // check if the file exists and is not a directory
          function tryFile(requestPath) {
            var fs = NativeModule.require('fs');
            var stats = statPath(requestPath);
            if (stats && !stats.isDirectory()) {
              return fs.realpathSync(requestPath, Module._realpathCache);
            }
            return false;
          }

          // given a path check a the file exists with any of the set extensions
          function tryExtensions(p, exts) {
            for (var i = 0, EL = exts.length; i < EL; i++) {
              var filename = tryFile(p + exts[i]);

              if (filename) {
                return filename;
              }
            }
            return false;
          }


          Module._findPath = function(request, paths) {
            var exts = Object.keys(Module._extensions);

            if (request.charAt(0) === '/') {
              paths = [''];
            }

            var trailingSlash = (request.slice(-1) === '/');

            var cacheKey = JSON.stringify({
              request: request,
              paths: paths
            });
            if (Module._pathCache[cacheKey]) {
              return Module._pathCache[cacheKey];
            }

            // For each path
            for (var i = 0, PL = paths.length; i < PL; i++) {
              var basePath = path.resolve(paths[i], request);
              var filename;

              if (!trailingSlash) {
                // try to join the request to the path
                filename = tryFile(basePath);

                if (!filename && !trailingSlash) {
                  // try it with each of the extensions
                  filename = tryExtensions(basePath, exts);
                }
              }

              if (!filename) {
                filename = tryPackage(basePath, exts);
              }

              if (!filename) {
                // try it with each of the extensions at "index"
                filename = tryExtensions(path.resolve(basePath, 'index'), exts);
              }

              if (filename) {
                Module._pathCache[cacheKey] = filename;
                return filename;
              }
            }
            return false;
          };

          // 'from' is the __dirname of the module.
          Module._nodeModulePaths = function(from) {
            // guarantee that 'from' is absolute.
            from = path.resolve(from);

            // note: this approach *only* works when the path is guaranteed
            // to be absolute.  Doing a fully-edge-case-correct path.split
            // that works on both Windows and Posix is non-trivial.
            var splitRe = process.platform === 'win32' ? /[\/\\]/ : /\//;
            // yes, '/' works on both, but let's be a little canonical.
            var joiner = process.platform === 'win32' ? '\\' : '/';
            var paths = [];
            var parts = from.split(splitRe);

            for (var tip = parts.length - 1; tip >= 0; tip--) {
              // don't search in .../node_modules/node_modules
              if (parts[tip] === 'node_modules') continue;
              var dir = parts.slice(0, tip + 1).concat('node_modules').join(joiner);
              paths.push(dir);
            }

            return paths;
          };


          Module._resolveLookupPaths = function(request, parent) {
            if (NativeModule.exists(request)) {
              return [request, []];
            }

            var start = request.substring(0, 2);
            if (start !== './' && start !== '..') {
              var paths = modulePaths;
              if (parent) {
                if (!parent.paths) parent.paths = [];
                paths = parent.paths.concat(paths);
              }
              return [request, paths];
            }

            // with --eval, parent.id is not set and parent.filename is null
            if (!parent || !parent.id || !parent.filename) {
              // make require('./path/to/foo') work - normally the path is taken
              // from realpath(__filename) but with eval there is no filename
              var mainPaths = ['.'].concat(modulePaths);
              mainPaths = Module._nodeModulePaths('.').concat(mainPaths);
              return [request, mainPaths];
            }

            // Is the parent an index module?
            // We can assume the parent has a valid extension,
            // as it already has been accepted as a module.
            var isIndex = /^index\.\w+?$/.test(path.basename(parent.filename));
            var parentIdPath = isIndex ? parent.id : path.dirname(parent.id);
            var id = path.resolve(parentIdPath, request);

            // make sure require('./path') and require('path') get distinct ids, even
            // when called from the toplevel js file
            if (parentIdPath === '.' && id.indexOf('/') === -1) {
              id = './' + id;
            }

            debug('RELATIVE: requested:' + request + ' set ID to: ' + id + ' from ' + parent.id);

            return [id, [path.dirname(parent.filename)]];
          };


          Module._load = function(request, parent, isMain) {
            if (parent) {
              debug('Module._load REQUEST  ' + (request) + ' parent: ' + parent.id);
            }

            var filename = Module._resolveFilename(request, parent);

            var cachedModule = Module._cache[filename];
            if (cachedModule) {
              return cachedModule.exports;
            }

            if (NativeModule.exists(filename)) {
              // REPL is a special case, because it needs the real require.
              if (filename == 'repl') {
                var replModule = new Module('repl');
                replModule._compile(NativeModule.getSource('repl'), 'repl.js');
                NativeModule._cache.repl = replModule;
                return replModule.exports;
              }

              debug('load native module ' + request);
              return NativeModule.require(filename);
            }

            var module = new Module(filename, parent);

            if (isMain) {
              process.mainModule = module;
              module.id = '.';
            }

            Module._cache[filename] = module;

            var hadException = true;

            try {
              module.load(filename);
              hadException = false;
            } finally {
              if (hadException) {
                delete Module._cache[filename];
              }
            }

            return module.exports;
          };

          Module._resolveFilename = function(request, parent) {
            if (NativeModule.exists(request)) {
              return request;
            }

            var resolvedModule = Module._resolveLookupPaths(request, parent);
            var id = resolvedModule[0];
            var paths = resolvedModule[1];

            // look up the filename first, since that's the cache key.
            debug('looking for ' + JSON.stringify(id) + ' in ' + JSON.stringify(paths));

            var filename = Module._findPath(request, paths);
            if (!filename) {
              var err = new Error("Cannot find module '" + request + "'");
              err.code = 'MODULE_NOT_FOUND';
              throw err;
            }
            return filename;
          };


          Module.prototype.load = function(filename) {
            debug('load ' + JSON.stringify(filename) + ' for module ' + JSON.stringify(this.id));

            assert(!this.loaded);
            this.filename = filename;
            this.paths = Module._nodeModulePaths(path.dirname(filename));

            var extension = path.extname(filename) || '.js';
            if (!Module._extensions[extension]) extension = '.js';
            Module._extensions[extension](this, filename);
            this.loaded = true;
          };


          Module.prototype.require = function(path) {
            return Module._load(path, this);
          };


          // Resolved path to process.argv[1] will be lazily placed here
          // (needed for setting breakpoint when called with --debug-brk)
          var resolvedArgv;


          // Returns exception if any
          Module.prototype._compile = function(content, filename) {
            var self = this;
            // remove shebang
            content = content.replace(/^\#\!.*/, '');

            function require(path) {
              return self.require(path);
            }

            require.resolve = function(request) {
              return Module._resolveFilename(request, self);
            };

            Object.defineProperty(require, 'paths', {
              get: function() {
                throw new Error('require.paths is removed. Use ' + 'node_modules folders, or the NODE_PATH ' + 'environment variable instead.');
              }
            });

            require.main = process.mainModule;

            // Enable support to add extra extension types
            require.extensions = Module._extensions;
            require.registerExtension = function() {
              throw new Error('require.registerExtension() removed. Use ' + 'require.extensions instead.');
            };

            require.cache = Module._cache;

            var dirname = path.dirname(filename);

            if (Module._contextLoad) {
              if (self.id !== '.') {
                debug('load submodule');
                // not root module
                var sandbox = {};
                for (var k in global) {
                  sandbox[k] = global[k];
                }
                sandbox.require = require;
                sandbox.exports = self.exports;
                sandbox.__filename = filename;
                sandbox.__dirname = dirname;
                sandbox.module = self;
                sandbox.global = sandbox;
                sandbox.root = root;

                return runInNewContext(content, sandbox, filename, true);
              }

              debug('load root module');
              // root module
              global.require = require;
              global.exports = self.exports;
              global.__filename = filename;
              global.__dirname = dirname;
              global.module = self;

              return runInThisContext(content, filename, true);
            }

            // create wrapper function
            var wrapper = Module.wrap(content);

            var compiledWrapper = runInThisContext(wrapper, filename, true);
            if (global.v8debug) {
              if (!resolvedArgv) {
                // we enter the repl if we're not given a filename argument.
                if (process.argv[1]) {
                  resolvedArg = Module._resolveFilename(process.argv[1], null);
                } else {
                  resolvedArg = 'repl';
                }
              }

              // Set breakpoint on module start
              if (filename === resolvedArgv) {
                global.v8debug.Debug.setBreakPoint(compiledWrapper, 0, 0);
              }
            }
            var args = [self.exports, require, self, filename, dirname];
            return compiledWrapper.apply(self.exports, args);
          };


          function stripBOM(content) {
            // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
            // because the buffer-to-string conversion in `fs.readFileSync()`
            // translates it to FEFF, the UTF-16 BOM.
            if (content.charCodeAt(0) === 0xFEFF) {
              content = content.slice(1);
            }
            return content;
          }


          // Native extension for .js
          Module._extensions['.js'] = function(module, filename) {
            var content = NativeModule.require('fs').readFileSync(filename, 'utf8');
            module._compile(stripBOM(content), filename);
          };

          // We've already pre-compiled the CoffeeScript so we can embed the source and
          // have it show up in the debugger
          Module._extensions['.coffee'] = Module._extensions['.js']


          // Native extension for .json
          Module._extensions['.json'] = function(module, filename) {
            var content = NativeModule.require('fs').readFileSync(filename, 'utf8');
            try {
              module.exports = JSON.parse(stripBOM(content));
            } catch (err) {
              err.message = filename + ': ' + err.message;
              throw err;
            }
          };


          //Native extension for .node
          Module._extensions['.node'] = function(module, filename) {
            process.dlopen(filename, module.exports);
          };


          // bootstrap main module.
          Module.runMain = function() {
            // Load the main module--the command line argument.
            Module._load(process.argv[1], null, true);
          };

          Module._initPaths = function() {
            var paths = [path.resolve(process.execPath, '..', '..', 'lib', 'node')];

            if (process.env['HOME']) {
              paths.unshift(path.resolve(process.env['HOME'], '.node_libraries'));
              paths.unshift(path.resolve(process.env['HOME'], '.node_modules'));
            }

            if (process.env['NODE_PATH']) {
              var splitter = process.platform === 'win32' ? ';' : ':';
              paths = process.env['NODE_PATH'].split(splitter).concat(paths);
            }

            modulePaths = paths;

            // clone as a read-only copy, for introspection.
            Module.globalPaths = modulePaths.slice(0);
          };

          // bootstrap repl
          Module.requireRepl = function() {
            return Module._load('repl', '.');
          };

          Module._initPaths();

          // backwards compatibility
          Module.Module = Module;

        },

        "7b51c3f0555ccb0c0f1fcd91d389ea1a": // from: 
        function(exports, require, module, __filename, __dirname) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.


          var isWindows = process.platform === 'win32';
          var util = require('util');


          // resolves . and .. elements in a path array with directory names there
          // must be no slashes, empty elements, or device names (c:\) in the array
          // (so also no leading and trailing slashes - it does not distinguish
          // relative and absolute paths)
          function normalizeArray(parts, allowAboveRoot) {
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === '.') {
                parts.splice(i, 1);
              } else if (last === '..') {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (allowAboveRoot) {
              for (; up--; up) {
                parts.unshift('..');
              }
            }

            return parts;
          }


          if (isWindows) {
            // Regex to split a windows path into three parts: [*, device, slash,
            // tail] windows-only
            var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?([\\\/])?([\s\S]*?)$/;

            // Regex to split the tail part of the above into [*, dir, basename, ext]
            var splitTailRe = /^([\s\S]+[\\\/](?!$)|[\\\/])?((?:\.{1,2}$|[\s\S]+?)?(\.[^.\/\\]*)?)$/;

            // Function to split a filename into [root, dir, basename, ext]
            // windows version
            var splitPath = function(filename) {
              // Separate device+slash from tail
              var result = splitDeviceRe.exec(filename),
                device = (result[1] || '') + (result[2] || ''),
                tail = result[3] || '';
              // Split the tail into dir, basename and extension
              var result2 = splitTailRe.exec(tail),
                dir = result2[1] || '',
                basename = result2[2] || '',
                ext = result2[3] || '';
              return [device, dir, basename, ext];
            };

            // path.resolve([from ...], to)
            // windows version
            exports.resolve = function() {
              var resolvedDevice = '',
                resolvedTail = '',
                resolvedAbsolute = false;

              for (var i = arguments.length - 1; i >= -1; i--) {
                var path;
                if (i >= 0) {
                  path = arguments[i];
                } else if (!resolvedDevice) {
                  path = process.cwd();
                } else {
                  // Windows has the concept of drive-specific current working
                  // directories. If we've resolved a drive letter but not yet an
                  // absolute path, get cwd for that drive. We're sure the device is not
                  // an unc path at this points, because unc paths are always absolute.
                  path = process.env['=' + resolvedDevice];
                  // Verify that a drive-local cwd was found and that it actually points
                  // to our drive. If not, default to the drive's root.
                  if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\') {
                    path = resolvedDevice + '\\';
                  }
                }

                // Skip empty and invalid entries
                if (typeof path !== 'string' || !path) {
                  continue;
                }

                var result = splitDeviceRe.exec(path),
                  device = result[1] || '',
                  isUnc = device && device.charAt(1) !== ':',
                  isAbsolute = !! result[2] || isUnc, // UNC paths are always absolute
                  tail = result[3];

                if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                  // This path points to another device so it is not applicable
                  continue;
                }

                if (!resolvedDevice) {
                  resolvedDevice = device;
                }
                if (!resolvedAbsolute) {
                  resolvedTail = tail + '\\' + resolvedTail;
                  resolvedAbsolute = isAbsolute;
                }

                if (resolvedDevice && resolvedAbsolute) {
                  break;
                }
              }

              // Replace slashes (in UNC share name) by backslashes
              resolvedDevice = resolvedDevice.replace(/\//g, '\\');

              // At this point the path should be resolved to a full absolute path,
              // but handle relative paths to be safe (might happen when process.cwd()
              // fails)

              // Normalize the tail path

              function f(p) {
                return !!p;
              }

              resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f), !resolvedAbsolute).join('\\');

              return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) || '.';
            };

            // windows version
            exports.normalize = function(path) {
              var result = splitDeviceRe.exec(path),
                device = result[1] || '',
                isUnc = device && device.charAt(1) !== ':',
                isAbsolute = !! result[2] || isUnc, // UNC paths are always absolute
                tail = result[3],
                trailingSlash = /[\\\/]$/.test(tail);

              // Normalize the tail path
              tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
                return !!p;
              }), !isAbsolute).join('\\');

              if (!tail && !isAbsolute) {
                tail = '.';
              }
              if (tail && trailingSlash) {
                tail += '\\';
              }

              // Convert slashes to backslashes when `device` points to an UNC root.
              device = device.replace(/\//g, '\\');

              return device + (isAbsolute ? '\\' : '') + tail;
            };

            // windows version
            exports.join = function() {
              function f(p) {
                return p && typeof p === 'string';
              }

              var paths = Array.prototype.filter.call(arguments, f);
              var joined = paths.join('\\');

              // Make sure that the joined path doesn't start with two slashes
              // - it will be mistaken for an unc path by normalize() -
              // unless the paths[0] also starts with two slashes
              if (/^[\\\/]{2}/.test(joined) && !/^[\\\/]{2}/.test(paths[0])) {
                joined = joined.substr(1);
              }

              return exports.normalize(joined);
            };

            // path.relative(from, to)
            // it will solve the relative path from 'from' to 'to', for instance:
            // from = 'C:\\orandea\\test\\aaa'
            // to = 'C:\\orandea\\impl\\bbb'
            // The output of the function should be: '..\\..\\impl\\bbb'
            // windows version
            exports.relative = function(from, to) {
              from = exports.resolve(from);
              to = exports.resolve(to);

              // windows is not case sensitive
              var lowerFrom = from.toLowerCase();
              var lowerTo = to.toLowerCase();

              function trim(arr) {
                var start = 0;
                for (; start < arr.length; start++) {
                  if (arr[start] !== '') break;
                }

                var end = arr.length - 1;
                for (; end >= 0; end--) {
                  if (arr[end] !== '') break;
                }

                if (start > end) return [];
                return arr.slice(start, end - start + 1);
              }

              var toParts = trim(to.split('\\'));

              var lowerFromParts = trim(lowerFrom.split('\\'));
              var lowerToParts = trim(lowerTo.split('\\'));

              var length = Math.min(lowerFromParts.length, lowerToParts.length);
              var samePartsLength = length;
              for (var i = 0; i < length; i++) {
                if (lowerFromParts[i] !== lowerToParts[i]) {
                  samePartsLength = i;
                  break;
                }
              }

              if (samePartsLength == 0) {
                return to;
              }

              var outputParts = [];
              for (var i = samePartsLength; i < lowerFromParts.length; i++) {
                outputParts.push('..');
              }

              outputParts = outputParts.concat(toParts.slice(samePartsLength));

              return outputParts.join('\\');
            };

            exports.sep = '\\';

          } else /* posix */
          {

            // Split a filename into [root, dir, basename, ext], unix version
            // 'root' is just a slash, or nothing.
            var splitPathRe = /^(\/?)([\s\S]+\/(?!$)|\/)?((?:\.{1,2}$|[\s\S]+?)?(\.[^.\/]*)?)$/;
            var splitPath = function(filename) {
              var result = splitPathRe.exec(filename);
              return [result[1] || '', result[2] || '', result[3] || '', result[4] || ''];
            };

            // path.resolve([from ...], to)
            // posix version
            exports.resolve = function() {
              var resolvedPath = '',
                resolvedAbsolute = false;

              for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path = (i >= 0) ? arguments[i] : process.cwd();

                // Skip empty and invalid entries
                if (typeof path !== 'string' || !path) {
                  continue;
                }

                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charAt(0) === '/';
              }

              // At this point the path should be resolved to a full absolute path, but
              // handle relative paths to be safe (might happen when process.cwd() fails)

              // Normalize the path
              resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
                return !!p;
              }), !resolvedAbsolute).join('/');

              return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
            };

            // path.normalize(path)
            // posix version
            exports.normalize = function(path) {
              var isAbsolute = path.charAt(0) === '/',
                trailingSlash = path.substr(-1) === '/';

              // Normalize the path
              path = normalizeArray(path.split('/').filter(function(p) {
                return !!p;
              }), !isAbsolute).join('/');

              if (!path && !isAbsolute) {
                path = '.';
              }
              if (path && trailingSlash) {
                path += '/';
              }

              return (isAbsolute ? '/' : '') + path;
            };


            // posix version
            exports.join = function() {
              var paths = Array.prototype.slice.call(arguments, 0);
              return exports.normalize(paths.filter(function(p, index) {
                return p && typeof p === 'string';
              }).join('/'));
            };


            // path.relative(from, to)
            // posix version
            exports.relative = function(from, to) {
              from = exports.resolve(from).substr(1);
              to = exports.resolve(to).substr(1);

              function trim(arr) {
                var start = 0;
                for (; start < arr.length; start++) {
                  if (arr[start] !== '') break;
                }

                var end = arr.length - 1;
                for (; end >= 0; end--) {
                  if (arr[end] !== '') break;
                }

                if (start > end) return [];
                return arr.slice(start, end - start + 1);
              }

              var fromParts = trim(from.split('/'));
              var toParts = trim(to.split('/'));

              var length = Math.min(fromParts.length, toParts.length);
              var samePartsLength = length;
              for (var i = 0; i < length; i++) {
                if (fromParts[i] !== toParts[i]) {
                  samePartsLength = i;
                  break;
                }
              }

              var outputParts = [];
              for (var i = samePartsLength; i < fromParts.length; i++) {
                outputParts.push('..');
              }

              outputParts = outputParts.concat(toParts.slice(samePartsLength));

              return outputParts.join('/');
            };

            exports.sep = '/';
          }


          exports.dirname = function(path) {
            var result = splitPath(path),
              root = result[0],
              dir = result[1];

            if (!root && !dir) {
              // No dirname whatsoever
              return '.';
            }

            if (dir) {
              // It has a dirname, strip trailing slash
              dir = dir.substr(0, dir.length - 1);
            }

            return root + dir;
          };


          exports.basename = function(path, ext) {
            var f = splitPath(path)[2];
            // TODO: make this comparison case-insensitive on windows?
            if (ext && f.substr(-1 * ext.length) === ext) {
              f = f.substr(0, f.length - ext.length);
            }
            return f;
          };


          exports.extname = function(path) {
            return splitPath(path)[3];
          };


          exports.exists = util.deprecate(function(path, callback) {
            require('fs').exists(path, callback);
          }, 'path.exists is now called `fs.exists`.');


          exports.existsSync = util.deprecate(function(path) {
            return require('fs').existsSync(path);
          }, 'path.existsSync is now called `fs.existsSync`.');


          if (isWindows) {
            exports._makeLong = function(path) {
              path = '' + path;
              if (!path) {
                return '';
              }

              var resolvedPath = exports.resolve(path);

              if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
                // path is local filesystem path, which needs to be converted
                // to long UNC path.
                return '\\\\?\\' + resolvedPath;
              } else if (/^\\\\[^?.]/.test(resolvedPath)) {
                // path is network UNC path, which needs to be converted
                // to long UNC path.
                return '\\\\?\\UNC\\' + resolvedPath.substring(2);
              }

              return path;
            };
          } else {
            exports._makeLong = function(path) {
              return path;
            };
          }

        },

        "d0c9d6cc2490c964b789d43ae4803b7b": // from: 
        function(exports, require, module, __filename, __dirname) {
          var punycode = {
            encode: function(s) {
              return s
            }
          };

          exports.parse = urlParse;
          exports.resolve = urlResolve;
          exports.resolveObject = urlResolveObject;
          exports.format = urlFormat;

          function arrayIndexOf(array, subject) {
            for (var i = 0, j = array.length; i < j; i++) {
              if (array[i] == subject) return i;
            }
            return -1;
          }

          var objectKeys = Object.keys || function objectKeys(object) {
              if (object !== Object(object)) throw new TypeError('Invalid object');
              var keys = [];
              for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
              return keys;
            }

            // Reference: RFC 3986, RFC 1808, RFC 2396

            // define these here so at least they only have to be
            // compiled once on the first module load.
          var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]+$/,
            // RFC 2396: characters reserved for delimiting URLs.
            delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
            // RFC 2396: characters not allowed for various reasons.
            unwise = ['{', '}', '|', '\\', '^', '~', '[', ']', '`'].concat(delims),
            // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
            autoEscape = ['\''],
            // Characters that are never ever allowed in a hostname.
            // Note that any invalid chars are also handled, but these
            // are the ones that are *expected* to be seen, so we fast-path
            // them.
            nonHostChars = ['%', '/', '?', ';', '#'].concat(unwise).concat(autoEscape),
            nonAuthChars = ['/', '@', '?', '#'].concat(delims),
            hostnameMaxLen = 255,
            hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
            hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
            // protocols that can allow "unsafe" and "unwise" chars.
            unsafeProtocol = {
              'javascript': true,
              'javascript:': true
            },
            // protocols that never have a hostname.
            hostlessProtocol = {
              'javascript': true,
              'javascript:': true
            },
            // protocols that always have a path component.
            pathedProtocol = {
              'http': true,
              'https': true,
              'ftp': true,
              'gopher': true,
              'file': true,
              'http:': true,
              'ftp:': true,
              'gopher:': true,
              'file:': true
            },
            // protocols that always contain a // bit.
            slashedProtocol = {
              'http': true,
              'https': true,
              'ftp': true,
              'gopher': true,
              'file': true,
              'http:': true,
              'https:': true,
              'ftp:': true,
              'gopher:': true,
              'file:': true
            },
            querystring = require('querystring');

          function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && typeof(url) === 'object' && url.href) return url;

            if (typeof url !== 'string') {
              throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
            }

            var out = {},
            rest = url;

            // cut off any delimiters.
            // This is to support parse stuff like "<http://foo.com>"
            for (var i = 0, l = rest.length; i < l; i++) {
              if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;
            }
            if (i !== 0) rest = rest.substr(i);


            var proto = protocolPattern.exec(rest);
            if (proto) {
              proto = proto[0];
              var lowerProto = proto.toLowerCase();
              out.protocol = lowerProto;
              rest = rest.substr(proto.length);
            }

            // figure out if it's got a host
            // user@server is *always* interpreted as a hostname, and url
            // resolution will treat //foo/bar as host=foo,path=bar because that's
            // how the browser resolves relative URLs.
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
              var slashes = rest.substr(0, 2) === '//';
              if (slashes && !(proto && hostlessProtocol[proto])) {
                rest = rest.substr(2);
                out.slashes = true;
              }
            }

            if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
              // there's a hostname.
              // the first instance of /, ?, ;, or # ends the host.
              // don't enforce full RFC correctness, just be unstupid about it.

              // If there is an @ in the hostname, then non-host chars *are* allowed
              // to the left of the first @ sign, unless some non-auth character
              // comes *before* the @-sign.
              // URLs are obnoxious.
              var atSign = arrayIndexOf(rest, '@');
              if (atSign !== -1) {
                // there *may be* an auth
                var hasAuth = true;
                for (var i = 0, l = nonAuthChars.length; i < l; i++) {
                  var index = arrayIndexOf(rest, nonAuthChars[i]);
                  if (index !== -1 && index < atSign) {
                    // not a valid auth.  Something like http://foo.com/bar@baz/
                    hasAuth = false;
                    break;
                  }
                }
                if (hasAuth) {
                  // pluck off the auth portion.
                  out.auth = rest.substr(0, atSign);
                  rest = rest.substr(atSign + 1);
                }
              }

              var firstNonHost = -1;
              for (var i = 0, l = nonHostChars.length; i < l; i++) {
                var index = arrayIndexOf(rest, nonHostChars[i]);
                if (index !== -1 && (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
              }

              if (firstNonHost !== -1) {
                out.host = rest.substr(0, firstNonHost);
                rest = rest.substr(firstNonHost);
              } else {
                out.host = rest;
                rest = '';
              }

              // pull out port.
              var p = parseHost(out.host);
              var keys = objectKeys(p);
              for (var i = 0, l = keys.length; i < l; i++) {
                var key = keys[i];
                out[key] = p[key];
              }

              // we've indicated that there is a hostname,
              // so even if it's empty, it has to be present.
              out.hostname = out.hostname || '';

              // validate a little.
              if (out.hostname.length > hostnameMaxLen) {
                out.hostname = '';
              } else {
                var hostparts = out.hostname.split(/\./);
                for (var i = 0, l = hostparts.length; i < l; i++) {
                  var part = hostparts[i];
                  if (!part) continue;
                  if (!part.match(hostnamePartPattern)) {
                    var newpart = '';
                    for (var j = 0, k = part.length; j < k; j++) {
                      if (part.charCodeAt(j) > 127) {
                        // we replace non-ASCII char with a temporary placeholder
                        // we need this to make sure size of hostname is not
                        // broken by replacing non-ASCII by nothing
                        newpart += 'x';
                      } else {
                        newpart += part[j];
                      }
                    }
                    // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                      var validParts = hostparts.slice(0, i);
                      var notHost = hostparts.slice(i + 1);
                      var bit = part.match(hostnamePartStart);
                      if (bit) {
                        validParts.push(bit[1]);
                        notHost.unshift(bit[2]);
                      }
                      if (notHost.length) {
                        rest = '/' + notHost.join('.') + rest;
                      }
                      out.hostname = validParts.join('.');
                      break;
                    }
                  }
                }
              }

              // hostnames are always lower case.
              out.hostname = out.hostname.toLowerCase();

              // IDNA Support: Returns a puny coded representation of "domain".
              // It only converts the part of the domain name that
              // has non ASCII characters. I.e. it dosent matter if
              // you call it with a domain that already is in ASCII.
              var domainArray = out.hostname.split('.');
              var newOut = [];
              for (var i = 0; i < domainArray.length; ++i) {
                var s = domainArray[i];
                newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
              }
              out.hostname = newOut.join('.');

              out.host = (out.hostname || '') + ((out.port) ? ':' + out.port : '');
              out.href += out.host;
            }

            // now rest is set to the post-host stuff.
            // chop off any delim chars.
            if (!unsafeProtocol[lowerProto]) {

              // First, make 100% sure that any "autoEscape" chars get
              // escaped, even if encodeURIComponent doesn't think they
              // need to be.
              for (var i = 0, l = autoEscape.length; i < l; i++) {
                var ae = autoEscape[i];
                var esc = encodeURIComponent(ae);
                if (esc === ae) {
                  esc = escape(ae);
                }
                rest = rest.split(ae).join(esc);
              }

              // Now make sure that delims never appear in a url.
              var chop = rest.length;
              for (var i = 0, l = delims.length; i < l; i++) {
                var c = arrayIndexOf(rest, delims[i]);
                if (c !== -1) {
                  chop = Math.min(c, chop);
                }
              }
              rest = rest.substr(0, chop);
            }


            // chop off from the tail first.
            var hash = arrayIndexOf(rest, '#');
            if (hash !== -1) {
              // got a fragment string.
              out.hash = rest.substr(hash);
              rest = rest.slice(0, hash);
            }
            var qm = arrayIndexOf(rest, '?');
            if (qm !== -1) {
              out.search = rest.substr(qm);
              out.query = rest.substr(qm + 1);
              if (parseQueryString) {
                out.query = querystring.parse(out.query);
              }
              rest = rest.slice(0, qm);
            } else if (parseQueryString) {
              // no query string, but parseQueryString still requested
              out.search = '';
              out.query = {};
            }
            if (rest) out.pathname = rest;
            if (slashedProtocol[proto] && out.hostname && !out.pathname) {
              out.pathname = '/';
            }

            //to support http.request
            if (out.pathname || out.search) {
              out.path = (out.pathname ? out.pathname : '') + (out.search ? out.search : '');
            }

            // finally, reconstruct the href based on what has been validated.
            out.href = urlFormat(out);
            return out;
          }

          // format a parsed object into a url string
          function urlFormat(obj) {
            // ensure it's an object, and not a string url.
            // If it's an obj, this is a no-op.
            // this way, you can call url_format() on strings
            // to clean up potentially wonky urls.
            if (typeof(obj) === 'string') obj = urlParse(obj);

            var auth = obj.auth || '';
            if (auth) {
              auth = auth.split('@').join('%40');
              for (var i = 0, l = nonAuthChars.length; i < l; i++) {
                var nAC = nonAuthChars[i];
                auth = auth.split(nAC).join(encodeURIComponent(nAC));
              }
              auth += '@';
            }

            var protocol = obj.protocol || '',
              host = (obj.host !== undefined) ? auth + obj.host : obj.hostname !== undefined ? (
              auth + obj.hostname + (obj.port ? ':' + obj.port : '')) : false,
              pathname = obj.pathname || '',
              query = obj.query && ((typeof obj.query === 'object' && objectKeys(obj.query).length) ? querystring.stringify(obj.query) : '') || '',
              search = obj.search || (query && ('?' + query)) || '',
              hash = obj.hash || '';

            if (protocol && protocol.substr(-1) !== ':') protocol += ':';

            // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
            // unless they had them to begin with.
            if (obj.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
              host = '//' + (host || '');
              if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
            } else if (!host) {
              host = '';
            }

            if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
            if (search && search.charAt(0) !== '?') search = '?' + search;

            return protocol + host + pathname + search + hash;
          }

          function urlResolve(source, relative) {
            return urlFormat(urlResolveObject(source, relative));
          }

          function urlResolveObject(source, relative) {
            if (!source) return relative;

            source = urlParse(urlFormat(source), false, true);
            relative = urlParse(urlFormat(relative), false, true);

            // hash is always overridden, no matter what.
            source.hash = relative.hash;

            if (relative.href === '') {
              source.href = urlFormat(source);
              return source;
            }

            // hrefs like //foo/bar always cut to the protocol.
            if (relative.slashes && !relative.protocol) {
              relative.protocol = source.protocol;
              //urlParse appends trailing / to urls like http://www.example.com
              if (slashedProtocol[relative.protocol] && relative.hostname && !relative.pathname) {
                relative.path = relative.pathname = '/';
              }
              relative.href = urlFormat(relative);
              return relative;
            }

            if (relative.protocol && relative.protocol !== source.protocol) {
              // if it's a known url protocol, then changing
              // the protocol does weird things
              // first, if it's not file:, then we MUST have a host,
              // and if there was a path
              // to begin with, then we MUST have a path.
              // if it is file:, then the host is dropped,
              // because that's known to be hostless.
              // anything else is assumed to be absolute.
              if (!slashedProtocol[relative.protocol]) {
                relative.href = urlFormat(relative);
                return relative;
              }
              source.protocol = relative.protocol;
              if (!relative.host && !hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || '').split('/');
                while (relPath.length && !(relative.host = relPath.shift()));
                if (!relative.host) relative.host = '';
                if (!relative.hostname) relative.hostname = '';
                if (relPath[0] !== '') relPath.unshift('');
                if (relPath.length < 2) relPath.unshift('');
                relative.pathname = relPath.join('/');
              }
              source.pathname = relative.pathname;
              source.search = relative.search;
              source.query = relative.query;
              source.host = relative.host || '';
              source.auth = relative.auth;
              source.hostname = relative.hostname || relative.host;
              source.port = relative.port;
              //to support http.request
              if (source.pathname !== undefined || source.search !== undefined) {
                source.path = (source.pathname ? source.pathname : '') + (source.search ? source.search : '');
              }
              source.slashes = source.slashes || relative.slashes;
              source.href = urlFormat(source);
              return source;
            }

            var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
              isRelAbs = (
              relative.host !== undefined || relative.pathname && relative.pathname.charAt(0) === '/'),
              mustEndAbs = (isRelAbs || isSourceAbs || (source.host && relative.pathname)),
              removeAllDots = mustEndAbs,
              srcPath = source.pathname && source.pathname.split('/') || [],
              relPath = relative.pathname && relative.pathname.split('/') || [],
              psychotic = source.protocol && !slashedProtocol[source.protocol];

            // if the url is a non-slashed url, then relative
            // links like ../.. should be able
            // to crawl up to the hostname, as well.  This is strange.
            // source.protocol has already been set by now.
            // Later on, put the first path part into the host field.
            if (psychotic) {

              delete source.hostname;
              delete source.port;
              if (source.host) {
                if (srcPath[0] === '') srcPath[0] = source.host;
                else srcPath.unshift(source.host);
              }
              delete source.host;
              if (relative.protocol) {
                delete relative.hostname;
                delete relative.port;
                if (relative.host) {
                  if (relPath[0] === '') relPath[0] = relative.host;
                  else relPath.unshift(relative.host);
                }
                delete relative.host;
              }
              mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
            }

            if (isRelAbs) {
              // it's absolute.
              source.host = (relative.host || relative.host === '') ? relative.host : source.host;
              source.hostname = (relative.hostname || relative.hostname === '') ? relative.hostname : source.hostname;
              source.search = relative.search;
              source.query = relative.query;
              srcPath = relPath;
              // fall through to the dot-handling below.
            } else if (relPath.length) {
              // it's relative
              // throw away the existing file, and take the new path instead.
              if (!srcPath) srcPath = [];
              srcPath.pop();
              srcPath = srcPath.concat(relPath);
              source.search = relative.search;
              source.query = relative.query;
            } else if ('search' in relative) {
              // just pull out the search.
              // like href='?foo'.
              // Put this after the other two cases because it simplifies the booleans
              if (psychotic) {
                source.hostname = source.host = srcPath.shift();
                //occationaly the auth can get stuck only in host
                //this especialy happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ? source.host.split('@') : false;
                if (authInHost) {
                  source.auth = authInHost.shift();
                  source.host = source.hostname = authInHost.shift();
                }
              }
              source.search = relative.search;
              source.query = relative.query;
              //to support http.request
              if (source.pathname !== undefined || source.search !== undefined) {
                source.path = (source.pathname ? source.pathname : '') + (source.search ? source.search : '');
              }
              source.href = urlFormat(source);
              return source;
            }
            if (!srcPath.length) {
              // no path at all.  easy.
              // we've already handled the other stuff above.
              delete source.pathname;
              //to support http.request
              if (!source.search) {
                source.path = '/' + source.search;
              } else {
                delete source.path;
              }
              source.href = urlFormat(source);
              return source;
            }
            // if a url ENDs in . or .., then it must get a trailing slash.
            // however, if it ends in anything else non-slashy,
            // then it must NOT get a trailing slash.
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash = (
            (source.host || relative.host) && (last === '.' || last === '..') || last === '');

            // strip single dots, resolve double dots to parent dir
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = srcPath.length; i >= 0; i--) {
              last = srcPath[i];
              if (last == '.') {
                srcPath.splice(i, 1);
              } else if (last === '..') {
                srcPath.splice(i, 1);
                up++;
              } else if (up) {
                srcPath.splice(i, 1);
                up--;
              }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (!mustEndAbs && !removeAllDots) {
              for (; up--; up) {
                srcPath.unshift('..');
              }
            }

            if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
              srcPath.unshift('');
            }

            if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
              srcPath.push('');
            }

            var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

            // put the host back
            if (psychotic) {
              source.hostname = source.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
              //occationaly the auth can get stuck only in host
              //this especialy happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ? source.host.split('@') : false;
              if (authInHost) {
                source.auth = authInHost.shift();
                source.host = source.hostname = authInHost.shift();
              }
            }

            mustEndAbs = mustEndAbs || (source.host && srcPath.length);

            if (mustEndAbs && !isAbsolute) {
              srcPath.unshift('');
            }

            source.pathname = srcPath.join('/');
            //to support request.http
            if (source.pathname !== undefined || source.search !== undefined) {
              source.path = (source.pathname ? source.pathname : '') + (source.search ? source.search : '');
            }
            source.auth = relative.auth || source.auth;
            source.slashes = source.slashes || relative.slashes;
            source.href = urlFormat(source);
            return source;
          }

          function parseHost(host) {
            var out = {};
            var port = portPattern.exec(host);
            if (port) {
              port = port[0];
              out.port = port.substr(1);
              host = host.substr(0, host.length - port.length);
            }
            if (host) out.hostname = host;
            return out;
          }

        },

        "ddeff58ff67e5d2d686891fc66ebb2b7": // from: 
        function(exports, require, module, __filename, __dirname) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var formatRegExp = /%[sdj%]/g;
          exports.format = function(f) {
            if (typeof f !== 'string') {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(' ');
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
              if (x === '%') return '%';
              if (i >= len) return x;
              switch (x) {
              case '%s':
                return String(args[i++]);
              case '%d':
                return Number(args[i++]);
              case '%j':
                return JSON.stringify(args[i++]);
              default:
                return x;
              }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (x === null || typeof x !== 'object') {
                str += ' ' + x;
              } else {
                str += ' ' + inspect(x);
              }
            }
            return str;
          };


          // Mark that a method should not be used.
          // Returns a modified function which warns once by default.
          // If --no-deprecation is set, then it is a no-op.
          exports.deprecate = function(fn, msg) {
            if (process.noDeprecation === true) {
              return fn;
            }

            var warned = false;

            function deprecated() {
              if (!warned) {
                if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }

            return deprecated;
          };


          exports.print = function() {
            for (var i = 0, len = arguments.length; i < len; ++i) {
              process.stdout.write(String(arguments[i]));
            }
          };


          exports.puts = function() {
            for (var i = 0, len = arguments.length; i < len; ++i) {
              process.stdout.write(arguments[i] + '\n');
            }
          };


          exports.debug = function(x) {
            process.stderr.write('DEBUG: ' + x + '\n');
          };


          var error = exports.error = function(x) {
            for (var i = 0, len = arguments.length; i < len; ++i) {
              process.stderr.write(arguments[i] + '\n');
            }
          };


          /**
           * Echos the value of a value. Trys to print the value out
           * in the best way possible given the different types.
           *
           * @param {Object} obj The object to print out.
           * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
           *    properties of objects.
           * @param {Number} depth Depth in which to descend in object. Default is 2.
           * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
           *    output. Default is false (no coloring).
           */
          function inspect(obj, showHidden, depth, colors) {
            var ctx = {
              showHidden: showHidden,
              seen: [],
              stylize: colors ? stylizeWithColor : stylizeNoColor
            };
            return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
          }
          exports.inspect = inspect;


          // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
          inspect.colors = {
            'bold': [1, 22],
            'italic': [3, 23],
            'underline': [4, 24],
            'inverse': [7, 27],
            'white': [37, 39],
            'grey': [90, 39],
            'black': [30, 39],
            'blue': [34, 39],
            'cyan': [36, 39],
            'green': [32, 39],
            'magenta': [35, 39],
            'red': [31, 39],
            'yellow': [33, 39]
          };

          // Don't use 'blue' not visible on cmd.exe
          inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            // "name": intentionally not styling
            'regexp': 'red'
          };


          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
              return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
            } else {
              return str;
            }
          }


          function stylizeNoColor(str, styleType) {
            return str;
          }


          function arrayToHash(array) {
            var hash = {};

            array.forEach(function(val, idx) {
              hash[val] = true;
            });

            return hash;
          }


          function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (value && typeof value.inspect === 'function' &&
            // Filter out the util module, it's inspect function is special
            value.inspect !== exports.inspect &&
            // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
              return String(value.inspect(recurseTimes));
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }

            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
              if (typeof value === 'function') {
                var name = value.name ? ': ' + value.name : '';
                return ctx.stylize('[Function' + name + ']', 'special');
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date');
              }
              if (isError(value)) {
                return formatError(value);
              }
            }

            var base = '',
              array = false,
              braces = ['{', '}'];

            // Make Array say that they are Array
            if (isArray(value)) {
              array = true;
              braces = ['[', ']'];
            }

            // Make functions say that they are functions
            if (typeof value === 'function') {
              var n = value.name ? ': ' + value.name : '';
              base = ' [Function' + n + ']';
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value);
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value);
            }

            // Make error with message first say the error
            if (isError(value)) {
              base = ' ' + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              } else {
                return ctx.stylize('[Object]', 'special');
              }
            }

            ctx.seen.push(value);

            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function(key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }

            ctx.seen.pop();

            return reduceToSingleString(output, base, braces);
          }


          function formatPrimitive(ctx, value) {
            switch (typeof value) {
            case 'undefined':
              return ctx.stylize('undefined', 'undefined');

            case 'string':
              var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
              return ctx.stylize(simple, 'string');

            case 'number':
              return ctx.stylize('' + value, 'number');

            case 'boolean':
              return ctx.stylize('' + value, 'boolean');
            }
            // For some reason typeof null is "object", so special case here.
            if (value === null) {
              return ctx.stylize('null', 'null');
            }
          }


          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
          }


          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                String(i), true));
              } else {
                output.push('');
              }
            }
            keys.forEach(function(key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                key, true));
              }
            });
            return output;
          }


          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {
              value: value[key]
            };
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special');
              } else {
                str = ctx.stylize('[Getter]', 'special');
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special');
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']';
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (recurseTimes === null) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str.split('\n').map(function(line) {
                      return '  ' + line;
                    }).join('\n').substr(2);
                  } else {
                    str = '\n' + str.split('\n').map(function(line) {
                      return '   ' + line;
                    }).join('\n');
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special');
              }
            }
            if (typeof name === 'undefined') {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify('' + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, 'name');
              } else {
                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, 'string');
              }
            }

            return name + ': ' + str;
          }


          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
              numLinesEst++;
              if (cur.indexOf('\n') >= 0) numLinesEst++;
              return prev + cur.length + 1;
            }, 0);

            if (length > 60) {
              return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
          }


          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          function isArray(ar) {
            return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
          }
          exports.isArray = isArray;


          function isRegExp(re) {
            return typeof re === 'object' && objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;


          function isDate(d) {
            return typeof d === 'object' && objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;


          function isError(e) {
            return typeof e === 'object' && objectToString(e) === '[object Error]';
          }
          exports.isError = isError;


          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }


          exports.p = exports.deprecate(function() {
            for (var i = 0, len = arguments.length; i < len; ++i) {
              error(exports.inspect(arguments[i]));
            }
          }, 'util.p: Use console.error() instead.');


          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
          }


          var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

          // 26 Feb 16:19:34
          function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()),
            pad(d.getMinutes()),
            pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
          }


          exports.log = function(msg) {
            exports.puts(timestamp() + ' - ' + msg.toString());
          };


          exports.exec = exports.deprecate(function() {
            return require('child_process').exec.apply(this, arguments);
          }, 'util.exec is now called `child_process.exec`.');


          function pump(readStream, writeStream, callback) {
            var callbackCalled = false;

            function call(a, b, c) {
              if (callback && !callbackCalled) {
                callback(a, b, c);
                callbackCalled = true;
              }
            }

            readStream.addListener('data', function(chunk) {
              if (writeStream.write(chunk) === false) readStream.pause();
            });

            writeStream.addListener('drain', function() {
              readStream.resume();
            });

            readStream.addListener('end', function() {
              writeStream.end();
            });

            readStream.addListener('close', function() {
              call();
            });

            readStream.addListener('error', function(err) {
              writeStream.end();
              call(err);
            });

            writeStream.addListener('error', function(err) {
              readStream.destroy();
              call(err);
            });
          }
          exports.pump = exports.deprecate(pump, 'util.pump() is deprecated. Use ReadableStream.prototype.pump() instead.');


          /**
           * Inherit the prototype methods from one constructor into another.
           *
           * The Function.prototype.inherits from lang.js rewritten as a standalone
           * function (not on Function.prototype). NOTE: If this file is to be loaded
           * during bootstrapping this function needs to be rewritten using some native
           * functions as prototype setup using normal JavaScript does not work as
           * expected during bootstrapping (see mirror.js in r114903).
           *
           * @param {function} ctor Constructor function which needs to inherit the
           *     prototype.
           * @param {function} superCtor Constructor function to inherit prototype from.
           */
          exports.inherits = function(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          };

          exports._extend = function(origin, add) {
            // Don't do anything if add isn't an object
            if (!add || typeof add !== 'object') return origin;

            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          };

          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }

        },

      },
      read: function(reference) {
        if (reference.__ref != null) {
          reference = reference.__ref;
        }
        return base64Decode(global.filesystem.content[reference]);
      }
    }
  };
})();

var process = (function() {
  var scopes;
  scopes = {
    evals: {
      NodeScript: {
        runInThisContext: function(source, filename, returnResult) {
          return global.filesystem.module_functions[source];
        },
        runInNewContext: function(source, filename, returnResult) {
          console.log("WARNING: runInNewContext doesn't work in the browser.");
          return global.filesystem.module_functions[source];
        }
      }
    }
  };
  return {
    platform: "browser",
    moduleLoadList: [],
    env: {},
    argv: ["node", "/"],
    binding: function(scope) {
      return scopes[scope];
    },
    cwd: function() {
      return "/";
    }
  };
})();

var NativeModule = (function() {
  var name, ref, runInThisContext, _ref;
  runInThisContext = process.binding('evals').NodeScript.runInThisContext;

  function NativeModule(id) {
    this.filename = id + '.js';
    this.id = id;
    this.exports = {};
    this.loaded = false;
  }

  NativeModule._source = {}
  NativeModule._cache = {};

  NativeModule.require = function(id) {
    if (id == 'native_module') {
      return NativeModule;
    }

    var cached = NativeModule.getCached(id);
    if (cached) {
      return cached.exports;
    }

    if (!NativeModule.exists(id)) {
      throw new Error('No such native module ' + id);
    }

    process.moduleLoadList.push('NativeModule ' + id);

    var nativeModule = new NativeModule(id);

    nativeModule.compile();
    nativeModule.cache();

    return nativeModule.exports;
  };

  NativeModule.getCached = function(id) {
    return NativeModule._cache[id];
  }

  NativeModule.exists = function(id) {
    return NativeModule._source.hasOwnProperty(id);
  }

  NativeModule.getSource = function(id) {
    return NativeModule._source[id];
  }

  NativeModule.wrap = function(script) {
    // return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];
    return script;
  };

  // NativeModule.wrapper = [
  //   '(function (exports, require, module, __filename, __dirname) { ',
  //   '\n});'
  // ];

  NativeModule.prototype.compile = function() {
    var source = NativeModule.getSource(this.id);
    source = NativeModule.wrap(source);
    var fn = runInThisContext(source, this.filename, true);
    fn(this.exports, NativeModule.require, this, this.filename);

    this.loaded = true;
  };

  NativeModule.prototype.cache = function() {
    NativeModule._cache[this.id] = this;
  };;

  _ref = global.filesystem.native_modules;
  for (name in _ref) {
    ref = _ref[name];
    NativeModule._source[name] = global.filesystem.read(ref);
  }
  return NativeModule;
})();

NativeModule.require("module").runMain();
